<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java基础面试之语法之一]]></title>
    <url>%2F2018%2F09%2F18%2Fava%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%AF%AD%E6%B3%95%E4%B9%8B%E4%B8%80%2F</url>
    <content type="text"><![CDATA[对于Java面试来说的本文只是对Java基础知识的一个小结，并不是什么武功秘籍或者什么速成法，更多的要求面试者自己脚踏实地的去学，多看书，多敲代码，多去思考，才是面试的王者之道。在这里作者提供了Java官方的API以供大家参考和学习[点我去官方API] 一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？一个“.java”源文件里面可以包含多个类，但是只允许有一个public类，并且类名必须和文件名一致。每个编译单元只能有一个public 类。这么做的意思是，每个编译单元只能有一个公开的接口，而这个接口就由其public 类来表示。你可以根据需要，往这个文件里面添加任意多个提供辅助功能的package 权限的类。但是如果这个编译单元里面有两个或两个以上的public 类的话，程序就不知道从哪里导入了，编译器就会报错。 &amp;和&amp;&amp;的区别&amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。 &amp;&amp;还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式，例如，对于if(str != null&amp;&amp; !str.equals(“”))表达式，当str为null时，后面的表达式不会执行，所以不会出现NullPointerException如果将&amp;&amp;改为&amp;，则会抛出NullPointerException异常。If(x==33 &amp;++y&gt;0) y会增长，If(x==33 &amp;&amp; ++y&gt;0)不会增长 &amp;还可以用作位运算符，当&amp;操作符两边的表达式不是boolean类型时，&amp;表示按位与操作，我们通常使用0x0f来与一个整数进行&amp;运算，来获取该整数的最低4个bit位，例如，0x31 &amp; 0x0f的结果为0x01。 备注：这道题先说两者的共同点，再说出&amp;&amp;和&amp;的特殊之处，并列举一些经典的例子来表明自己理解透彻深入、实际经验丰富。 下面的例子更清楚y增长 y没有增长 在JAVA中如何跳出当前的多重嵌套循环？在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break语句，即可跳出外层循环。例如， 并不推荐这种方式，让外层的循环条件表达式的结果可以受到里层循环体代码的控制，跳出本层循环 switch语句能否作用在byte上，能否作用在long上，能否作用在String上?在switch（expr1）中，expr1只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是int基本类型或Integer包装类型，由于，byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。显然，long符合switch的语法规定，并且不能被隐式转换成int类型，所以，它不能作用于swtich语句中。 short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?对于short s1 = 1; s1 += 1;由于 +=是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。 char型变量中能不能存贮一个中文汉字?为什么?当然是可以了，char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字。补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。 8、用最有效率的方法算出2乘以8等於几?2&lt;&lt;3,位移三位就可以了，而位运算cpu直接支持的，效率最高。 int和Integer有什么区别？Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。Java 为每个原始类型提供了包装类型： 原始类型: boolean，char，byte，short，int，long，float，double 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double 第二种情况 解释内存中的栈(stack)、堆(heap)和静态区(static area)的用法。通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；而通过new关键字和构造器创建的对象放在堆空间；程序中的字面量（literal）如直接书写的100、”hello”和常量都是放在静态区中。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，理论上整个内存没有被其他进程使用的空间甚至硬盘上的虚拟内存都可以被当成堆空间来使用。String str = new String(“hello”);上面的语句中变量str放在栈上，用new创建出来的字符串对象放在堆上，而”hello”这个字面量放在静态区。 数组有没有length()方法？String有没有length()方法？这个问题代码敲多了都应该知道，数组本身就有长度，String字符串则需要length方法来获取长度 构造器（constructor）是否可被重写（override）？构造器不能被继承，因此不能被重写，但可以被重载。 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的：(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；(2)如果两个对象的hashCode相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。补充：关于equals和hashCode方法，很多Java程序都知道，但很多人也就是仅仅知道而已，在Joshua Bloch的大作《Effective Java》（很多软件公司，《Effective Java》、《Java编程思想》以及《重构：改善既有代码质量》是Java程序员必看书籍，如果你还没看过，那就赶紧去亚马逊买一本吧）中是这样介绍equals方法的：首先equals方法必须满足自反性（x.equals(x)必须返回true）、对称性（x.equals(y)返回true时，y.equals(x)也必须返回true）、传递性（x.equals(y)和y.equals(z)都返回true时，x.equals(z)也必须返回true）和一致性（当x和y引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值），而且对于任何非null值的引用x，x.equals(null)必须返回false。实现高质量的equals方法的诀窍包括：1. 使用==操作符检查”参数是否为这个对象的引用”；2. 使用instanceof操作符检查”参数是否为正确的类型”；3. 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；4. 编写完equals方法后，问自己它是否满足对称性、传递性、一致性；5. 重写equals时总是要重写hashCode；6. 不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解。 是否可以继承String类？String 类是final类，不可以被继承。 补充：继承String本身就是一个错误的行为，对String类型最好的重用方式是关联关系（Has-A）和依赖关系（Use-A）而不是继承关系（Is-A）。 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？是值传递。Java语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。 String和StringBuilder、StringBuffer的区别？Java平台提供了两种类型的字符串：String和StringBuffer/StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer/StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是Java 5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer要高。 什么情况下用+运算符进行字符串连接比调用StringBuffer/StringBuilder对象的append方法连接字符串性能更好？string旦赋值或实例化后就不可更改，如果赋予新值将会重新开辟内存地址进行存储。而StringBuffer类使用append和insert等方法改变字符串值时只是在原有对象存储的内存地址上进行连续操作，减少了资源的开销 因此我们得出结论：当需要进行频繁修改字符串的操作时先建立StringBuffer类对象进行操作，将最后结果转化成String类对象返回，这样效率会高很多。 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。 面试题：华为的面试题中曾经问过这样一个问题 – “为什么不能根据返回类型来区分重载”，快说出你的答案吧！因为调用时不能指定类型信息，编译器不知道你要调用哪个函数。float max(int a, int b); int max(int a, int b); 描述一下JVM加载class文件的原理机制？JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。 由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。 类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。 当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明： Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。 抽象类（abstract class）和接口（interface）有什么异同？抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。 静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化，其语法看起来挺诡异的。 Java 中会存在内存泄漏吗，请简单描述。理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收，因此也会导致内存泄露的发生。例如hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。下面例子中的代码也会导致内存泄露。 抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。 阐述静态变量和实例变量的区别。静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。 静态变量是所有对象共有的，某一个对象将它的值改变了，其他对象再去获取它的值，得到的是改变后的值；实例变量则是每一个对象私有的，某一个对象将它的值改变了，不影响其他对象取值的结果，其他对象仍会得到实例变量一开始就被赋予的值。例： 1234567891011121314151617public class A&#123;static int a = 0; // 这是静态变量int b = 0; // 这是实例变量&#125; public class B&#123;public static void main (String[] args)&#123;A a1 = new A();A a2 = new A();a1.a = 3; // 对象a1将3赋值给aa1.b = 4 ; // 对象a1将4赋值给“它自己的b”System.out.println(a2.a); //结果为3 //静态变量是针对所有对象的，所以a1改变a的值，a2获取到的a的值也改变了的System.out.println(a2.b); //结果为0 //实例变量只改变自身所获取的值，所以a1获取的b的值改变了，不影响a2获取的b的值 &#125;&#125; GC是什么？为什么要有GC？GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显示的垃圾回收调用。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在Java诞生初期，垃圾回收是Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今Java的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得iOS的系统比Android系统有更好的用户体验，其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显示的垃圾回收调用。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在Java诞生初期，垃圾回收是Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今Java的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得iOS的系统比Android系统有更好的用户体验，其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。与垃圾回收相关的JVM参数： 12345678910-Xms / -Xmx — 堆的初始大小 / 堆的最大大小-Xmn — 堆中年轻代的大小-XX:-DisableExplicitGC — 让System.gc()不产生任何作用-XX:+PrintGCDetails — 打印GC的细节-XX:+PrintGCDateStamps — 打印GC操作的时间戳-XX:NewSize / XX:MaxNewSize — 设置新生代大小/新生代最大大小-XX:NewRatio — 可以设置老生代和新生代的比例-XX:PrintTenuringDistribution — 设置每次新生代GC后输出幸存者乐园中对象年龄的分布-XX:InitialTenuringThreshold / -XX:MaxTenuringThreshold：设置老年代阀值的初始值和最大值-XX:TargetSurvivorRatio：设置幸存区的目标使用率 String s = new String(“xyz”);创建了几个字符串对象？两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。 接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？接口可以继承接口，而且支持多重继承。抽象类可以实现(implements)接口，抽象类可继承具体类也可以继承抽象类。 Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？匿名的内部类不能extends（继承）其它类，但一个内部类可以作为一个接口，由另一个内部类实现。 12345678910111213141516171819202122232425262728293031323334353637class Car&#123; void move()&#123;&#125;&#125;interface Person&#123; void learn();&#125;abstract class Animal&#123; abstract void eat();&#125;public class AnonymousInnerClassDemo &#123; public static void main(String[] args) &#123; Car car = new Car()&#123; @Override void move() &#123; System.out.println("匿名内部类的move方法"); &#125; &#125;; car.move(); Person person = new Person() &#123; public void learn() &#123; System.out.println("匿名内部类的learn方法"); &#125; &#125;; person.learn(); Animal animal = new Animal() &#123; @Override void eat() &#123; System.out.println("匿名内部类的eat方法"); &#125; &#125;; animal.eat(); &#125;&#125; 指出下面程序的运行结果。执行结果：1a2b2b。创建对象时构造器的调用顺序是：先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。如果不能给出此题的正确答案，说明之前Java类加载机制还没有完全理解，赶紧再看看吧。 数据类型之间的转换： 如何将字符串转换为基本数据类型？ 如何将基本数据类型转换为字符串？调用基本数据类型对应的包装类中的方法parseXXX(String)或valueOf(String)即可返回相应基本类型； 一种方法是将基本数据类型与空字符串（””）连接（+）即可获得其所对应的字符串；另一种方法是调用String 类中的valueOf()方法返回相应字符串Character ch2 = ‘8’; （char是基本数据类型，Character是其包装类型。） int num2 = Integer.parseInt(ch2.toString()); 如何实现字符串的反转及替换？递归实现字符串反转 日期和时间： 如何取得年月日、小时分钟秒？ 如何取得从1970年1月1日0时0分0秒到现在的毫秒数？ 如何取得某月的最后一天？ 如何格式化日期？创建java.util.Calendar 实例，调用其get()方法传入不同的参数即可获得参数所对应的值。Java 8中可以使用java.time.LocalDateTimel来获取，代码如下所示。 以下方法均可获得该毫秒数。 Calendar.getInstance().getTimeInMillis(); System.currentTimeMillis(); Clock.systemDefaultZone().millis(); // Java 8 取得某月的最后一天 利用java.text.DataFormat 的子类（如SimpleDateFormat类）中的format(Date)方法可将日期格式化。Java 8中可以用java.time.format.DateTimeFormatter来格式化时间日期，代码如下所示。 打印昨天的当前时刻。 比较一下Java和JavaSciprt。基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身提供了非常丰富的内部对象供设计人员使用。 解释和编译：Java的源代码在执行之前，必须经过编译。JavaScript是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。（目前的浏览器几乎都使用了JIT（即时编译）技术来提升JavaScript的运行效率） 强类型变量和类型弱变量：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript的解释器在运行时检查推断其数据类型。 代码格式不一样。补充：上面列出的四点是网上流传的所谓的标准答案。其实Java和JavaScript最重要的区别是一个是静态语言，一个是动态语言。目前的编程语言的发展趋势是函数式语言和动态语言。在Java中类（class）是一等公民，而JavaScript中函数（function）是一等公民，因此JavaScript支持函数式编程，可以使用Lambda函数和闭包（closure），当然Java 8也开始支持函数式编程，提供了对Lambda表达式以及函数式接口的支持。对于这类问题，在面试的时候最好还是用自己的语言回答会更加靠谱，不要背网上所谓的标准答案。 Error和Exception有什么区别？Error表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。 提示：用递归编写程序时一定要牢记两点：1. 递归公式；2. 收敛条件（什么时候就不再继续递归）。 try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后?会执行，在方法返回调用者前执行。注意：在finally中改变返回值的做法是不好的，因为如果存在finally代码块，try中的return语句不会立马返回调用者，而是记录下返回值待finally代码块执行完毕之后再向调用者返回其值，然后如果在finally中修改了返回值，就会返回修改后的值。显然，在finally中返回或者修改返回值会对程序造成很大的困扰，C#中直接用编译错误的方式来阻止程序员干这种龌龊的事情，Java中也可以通过提升编译器的语法检查级别来产生警告或错误，Eclipse中可以在如图所示的地方进行设置，强烈建议将此项设置为编译错误。 Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是Throwable类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；try用来指定一块预防所有异常的程序；catch子句紧跟在try块后面，用来指定你想要捕获的异常的类型；throw语句用来明确地抛出一个异常；throws用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；finally为确保一段代码不管发生什么异常状况都要被执行；try语句可以嵌套，每当遇到一个try语句，异常的结构就会被放入异常栈中，直到所有的try语句都完成。如果下一级的try语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这种异常的try语句或者最终将异常抛给JVM。 运行时异常与受检异常有何异同？异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，在Effective Java中对异常的使用给出了以下指导原则： 不要将异常处理用于正常的控制流（设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常） 对可以恢复的情况使用受检异常，对编程错误使用运行时异常 避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生） 优先使用标准的异常 每个方法抛出的异常都要有文档 保持异常的原子性 不要在catch中忽略掉捕获到的异常 列出一些你常见的运行时异常？ - ArithmeticException（算术异常） - ClassCastException （类转换异常） - IllegalArgumentException （非法参数异常） - IndexOutOfBoundsException （下标越界异常） - NullPointerException （空指针异常） - SecurityException （安全异常） 阐述final、finally、finalize的区别。 final：修饰符（关键字）有三种用法：如果一个类被声明为final，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。将变量声明为final，可以保证它们在使用中不被改变，被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为final的方法也同样只能使用，不能在子类中被重写。 finally：通常放在try…catch…的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。 finalize：Object类中定义的方法，Java中允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize()方法可以整理系统资源或者执行其他清理工作。 List，Set,Map是否继承自Collection接口？List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。 阐述ArrayList、Vector、LinkedList的存储性能和特性。ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是Java中的遗留容器。LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector属于遗留容器（Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。 Collection和Collections的区别？Collection是一个接口，它是Set、List等容器的父接口；Collections是个一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。 List、Map、Set三个接口存取元素时，各有什么特点？List以特定索引来存取元素，可以有重复元素。Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。 TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。Collections工具类的sort方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java中对函数式编程的支持）。]]></content>
  </entry>
  <entry>
    <title><![CDATA[docker安装和使用]]></title>
    <url>%2F2018%2F09%2F18%2Fdocker%2F</url>
    <content type="text"><![CDATA[docker是什么Docker：是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的，可移植的，自给自足的容器。Docker的核心概念：镜像、仓库、容器 Docker镜像：是一个特殊的文件系统，提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。 Docker 容器（Container）：来运行应用。容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。 仓库（Repository）：是集中存放镜像文件的场所 一次完整docker的操作流程一般的流程中,client发pull命令从仓库把image拉到docker host，然后通过run命令指挥image到host上面弄一个container来跑这个image。当然也可以是相反的流程，client 通过build命令在host上面创建一个自己的image，然后通过push命令把image推到仓库。之后这个image可以被别的人或者自己pull。DOCKER在windows上的安装检查电脑环境检查版本，为了运行docker，你的机器必须是windows7或以上的64bit系统。 另外，你的机器必须支持硬件虚拟化技术(Hardware Virtualization Technology)并且已被启用。对于windows10系统来说，你可以在 任务管理器-&gt;性能 中查看到你的电脑是否开启了虚拟化 怎么开启虚拟化，因为电脑型号不一样，所以每台电脑进入BOIS的方式不一样，重启电脑，我的电脑是Lenovo的ThinkPad，所以我按的是F1，进入BOIS页面，找到Security，把Security下面的Virtualization里面的Intel(R) Virtualization Technology的状态改为Enable 然后再重启就好了。 下载dockerToolboxhttps://get.daocloud.io/toolbox/,下载新版本 全部next就可以了 安转成功之后桌面会多三个图标 如果安装完成之后桌面少了一个Oracle VM VirtualBox 的话，找到你的dockertoolbox安装目录下面的installers下面的virtualbox，双击virtualbox.msi进行安装。 双击Docker Quickstart Terminal图标，启动一个终端，第一次运行会比较就，一般会报下载对应的镜像iso到对C：下的docker路径的错误，把dockertoolbox下的boot2docker.iso复制放到你docker运行下载镜像的位置，再重新启动就可以了。 启动成功会出现这样的界面 docker在linux上的安装1.安装dockeryum install docker.x86_64 启动Dockerservice docker startlinux常用命令 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485ls -a(同时列出隐含文件), -l（输出一个比较完整的格式，除每个文件名外，增加显示文件 类型、权限、硬链接数、所有者名、组名、大小（byte）、及时间信息-----简化为 ll） mkdir 新建目录 例：mkdir test 命令会在当前目录下建立一个名为“test”的新目录 touch 创建文件 例：touch test/readme.txt 在 test 目录下创建 readme.txt文件 cd 切换目录 cd /. 到根目录 cd .. 上一级目录 cd /hahaha/hahaha 到指定目录 pwd 显示当前目录 mv 移动/重命名（加上 -i 参数询问是否覆盖） mv hello rock/ 移动到rock目录下 mv hello rock 重命名为rock cp 拷贝 （加上 -i 参数询问是否覆盖，-r 参数递归调用） cp -ir test/ workspace＂（递归复制 test 目录到 workpace 目录下并在覆盖时提示） rm 删除 （加上 -i 参数确认提示，-r 参数递归调用） rm -ir test/ 递归删除test目录及其子目录并询问 wget url 下载文件到当前目录 sudo 暂时获取超级用户权限（有默认时长）加上 -i 参数 没有时间限制,输入 exit或logout 退出 su 账户名 切换到某某用户模式，没有时间限制 ZIP 工具： 压缩文件 zip target.zip filename 压缩文件夹 zip -r target.zip dir -r 参数表示递归压缩子目录 解压 unzip target.zip tar 工具： -c: 建立压缩档案 -x：解压 -t：查看内容 -r：向压缩归档文件末尾追加文件 -u：更新原压缩包中的文件 这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用 其中一个。下面的参数是根据需要在压缩或解压档案时可选的。 -z：有gzip属性的 -j：有bz2属性的 -Z：有compress属性的 -v：显示所有过程 -O：将文件解开到标准输出 下面的参数-f是必须的 -f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名 例：tar -xvf file.tar //解压 tar包 tar -xzvf jdk-8u131-linux-x64.tar.gz -C /usr/local/java //解压jdk到指定文件夹 tar -cZf jpg.tar.Z *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用 compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z vim 编辑器： vim test.cpp vim 有两种模式，一种是普通模式，另一种是插入模式。执行上述命令以后进入普通模式。 按下字母键“i”进入插入模式，使用方向键移动光标到需要插入的位置，然后输入想要插入 的内容。编辑完成后按键“Esc”退出回到普通模式,在普通模式下输入冒号“:”，然后输入 w 回车，保存更改。接着输入“:q”退出。也可以直接输入“:wq”保存并退出（注意 w 一定要 在 q之前，先保存再退出）。 查找：在普通模式下输入“/查找内容”，回车，即可定位到第一个匹配项。接着按下字母 键“n”可以查找下一个。 撤销：普通模式下输入“:u”并回车，实现撤销 docker常用命令12345678docker search(-s) nginx 搜索相关镜像 加上-s 参数 选出至少start数范围的镜像docker push 192.168.0.100:5000/ubuntu 推送镜像库到私有源docker rmi（-f） 镜像名：版本号/镜像ID 删除镜像 （加上 -f 参数 强制删除）docker rmi $(docker images -q) 删除所有镜像docker save docker.io/tomcat:7.0.77-jre7 &gt;/root/mytomcat7.tar.gz 导出镜像docker load &lt; /root/mytomcat7.tar.gz 导入镜像如果你想要去查看一个镜像的运行效果，你需要先下载一个镜像，直接运行命令docker pull 镜像名 123456789101112131415161718192021docker ps 查看当前正在运行的容器 docker inspect name/image[name/image...] 查看详细 docker ps -a 查看所有容器的状态 docker start/stop(-t) id/name[name...] 启动/停止某个（多个）容器 -t 指定时间 docker kill (-s) name[name...] 强制中断 -s指定SIGINT信号类型，默认“kill” docker restart (-t) name[name...] 重启 -t 指定时间 docker pause name 暂停 docker unpause name 继续 docker rm(-$) name[name...] 移除 -f --force=false 强制移除运行中容器 -l --link=false 移除指定链接，保留底层容器 -v --volumes=false 移除容器关联卷 指令指南12345容器生命周期管理 — docker [run|start|stop|restart|kill|rm|pause|unpause]容器操作运维 — docker [ps|inspect|top|attach|events|logs|wait|export|port]镜像仓库 — docker [login|pull|push|search]本地镜像管理 — docker [images|rmi|tag|build|history|save|import]其他命令 — docker [info|version] 使用dockerfile制作镜像Docker与微服务-使用Maven插件构建Docker镜像（可以参照http://blog.csdn.net/qq_22841811/article/details/67369530） 打开我们的项目，在我们项目的src/main下面新建一个docker文件，在docker文件里面新建Dockerfile文本 FROM java:8 #From是from那个镜像，最好现在docker里面pull下来，不然构建的时候会在再下一遍 VOLUME /tmp #指定挂载点，该指令使容器中的一个目录具有持久化存储的功能，该目录可被容器本身使用，也可以共享给其他容器 1234567ADD microservice-discovery-eureka-0.0.1-SNAPSHOT.jar app.jar #复制文件RUN bash -c 'touch /app.jar' #run是启动容器后执行的命令EXPOSE 9000 #声明暴露的端口ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/app.jar"] Dockerfile文件修改pom.xml 1234567FROM Jjava:8 //来自那个基础镜像VOLUME /tmp //指定临时挂载点ADD microservice-discovery-eur.jar app.jar //把项目jar添加到app.jar里RUN bash -c 'touch/app.jar' //镜像运行后执行该命令EXPOSE:9000 //暴露出来访问的端口ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/app.jar"] //运行后执行的命令在maven的配置文件里面增加配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;build&gt; &lt;plugins&gt; &lt;!-- docker的maven插件，官网：https://github.com/spotify/docker-maven-plugin --&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.4.12&lt;/version&gt; &lt;configuration&gt; &lt;!-- 注意imageName一定要是符合正则[a-z0-9-_.]的，否则构建不会成功 --&gt; &lt;!-- 详见：https://github.com/spotify/docker-maven-plugin Invalid repository name ... only [a-z0-9-_.] are allowed --&gt; &lt;!-- 如果要将docker镜像push到DockerHub上去的话，这边的路径要和repo路径一致 --&gt; &lt;imageName&gt;eacdy/test&lt;/imageName&gt; &lt;!-- 指定Dockerfile所在的路径 --&gt; &lt;dockerDirectory&gt;$&#123;project.basedir&#125;/src/main/docker&lt;/dockerDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;/&lt;/targetPath&gt; &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt; &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;!-- 以下两行是为了docker push到DockerHub使用的。 --&gt; &lt;serverId&gt;docker-hub&lt;/serverId&gt; &lt;registryUrl&gt;https://index.docker.io/v1/&lt;/registryUrl&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 照上面修改后build之后的项目会报找不到2375端口的错误 需要我们去修改dockerhost的端口 1234567在控制台中输入 docker-machine env $Env:DOCKER_TLS_VERIFY = "1"$Env:DOCKER_HOST = "tcp://192.168.99.100:2376"$Env:DOCKER_CERT_PATH="C:\Users\Administrator\.docker\machine\machines\default（每个人的路径都不一样） 再去修改pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.4.12&lt;/version&gt; &lt;configuration&gt; &lt;imageName&gt;eacdy/test&lt;/imageName&gt; &lt;dockerDirectory&gt;$&#123;project.basedir&#125;/src/main/docker&lt;/dockerDirectory&gt; &lt;!-- 解决Connect to localhost:2375的问题的其中一种方式，注意要跟docker-machine env相一致 --&gt; &lt;dockerHost&gt;https://192.168.99.100:2376&lt;/dockerHost&gt; &lt;dockerCertPath&gt;C:\Users\Administrator\.docker\machine\machines\default&lt;/dockerCertPath&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;/&lt;/targetPath&gt; &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt; &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;!-- 以下两行是为了docker push到DockerHub使用的。 --&gt; &lt;serverId&gt;docker-hub&lt;/serverId&gt; &lt;registryUrl&gt;https://index.docker.io/v1/&lt;/registryUrl&gt; &lt;/configuration&gt;&lt;/plugin&gt; 这样build的项目就不会报错了 完美打包构建build项目。]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建docker私库]]></title>
    <url>%2F2018%2F09%2F12%2F%E6%90%AD%E5%BB%BAdocker%E7%A7%81%E5%BA%93%2F</url>
    <content type="text"><![CDATA[前面关于nexus的操作参考前面nexus的文章 1.新建私有私库 2.新建角色和用户 3.docker上传与下载 使用docker登录私库：密码** docker login youstudio.cn:7182给镜像打标记，设置为私库将要提交的路径： docker tag nginx:1.13.5 youstudio.cn:7182/xcfr/test/nginx:1.0.0 往私库上放置一个镜像： docker push youstudio.cn:7182/xcfr/test/nginx:1.0.0 从私库上拉取刚刚上传的镜像一个镜像： docker pull youstudio.cn:7182/xcfr/test/nginx:1.0.0 通过浏览器查看结果： 点击打开链接]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>docker私库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于highcharts+easui+java生成饼图]]></title>
    <url>%2F2018%2F09%2F12%2F%E5%9F%BA%E4%BA%8Ehighcharts-easui-java%E7%94%9F%E6%88%90%E9%A5%BC%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[前言：第一次接触饼图，刚开始没有思路，后面在网上找了一下对比了一下，发现用highcharts插件去生成图表特别简单，用起来还是非常简单的，只需要后台返回相应的数据前台用json接收一下，就可以完美的实现了。 一、先来个实体展示，让大家看看效果 （效果还是美美的） 二、要实现这个效果首先要去highcharts官网去下载你自己需要的图表简单的介绍下Highcharts，Highcharts是一个非常流行，界面美观的纯Javascript图表库。它主要包括两个部分：Highcharts和Highstock。Highcharts可以为您的网站或Web应用程序提供直观，互动式的图表。目前支持线，样条，面积，areaspline，柱形图，条形图，饼图和散点图类型。Highstock可以为您方便地建立股票或一般的时间轴图表。它包括先进的导航选项，预设的日期范围，日期选择器，滚动和平移等等。（下面是highcharts官网地址和demo） HIghChartS官网：http://www.highcharts.com/ HighCharts Demo:http://www.highcharts.com/demo/ 2.1引入相应的js文件才能实现页面效果由于我在Web开发框架中，主要采用了MVC+EasyUI的方式，因包含的文件如下所示。(每个图表需要引得文件官网的demo里面都有） 123456789101112131415161718&lt;script type="text/javascript" src="&lt;%=basePath%&gt;/view/report/highcharts.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="&lt;%=basePath%&gt;/js/grid.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="&lt;%=basePath%&gt;/view/report/exporting.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/view/report/jquery.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="&lt;%=basePath%&gt;/view/report/jquery.min.js"&gt;&lt;/script&gt;@*图表JS文件应用*@&lt;script type="text/javascript" src="&lt;%=basePath%&gt;/view/report/highcharts.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="&lt;%=basePath%&gt;/js/grid.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="&lt;%=basePath%&gt;/view/report/exporting.js"&gt;&lt;/script&gt; 三、图表的js代码首先是官网下载下来的图表代码 12345678910111213141516171819202122232425262728293031323334353637383940414243$(function () &#123; $('#container').highcharts(&#123; chart: &#123; plotBackgroundColor: null, plotBorderWidth: null, plotShadow: false &#125;, title: &#123; text: '2014 某网站上各个浏览器的访问量占比' &#125;, tooltip: &#123; headerFormat: '&#123;series.name&#125;&lt;br&gt;', pointFormat: '&#123;point.name&#125;: &lt;b&gt;&#123;point.percentage:.1f&#125;%&lt;/b&gt;' &#125;, plotOptions: &#123; pie: &#123; allowPointSelect: true, cursor: 'pointer', dataLabels: &#123; enabled: false &#125;, showInLegend: true &#125; &#125;, series: [&#123; type: 'pie', name: '浏览器访问量占比', data: [ ['Firefox', 45.0], ['IE', 26.8], &#123; name: 'Chrome', y: 12.8, sliced: true, selected: true &#125;, ['Safari', 8.5], ['Opera', 6.2], ['其他', 0.7] ] &#125;] &#125;);&#125;); 改动后的样式，只需要把data换成动态的数组用json来接收 1234567891011121314151617181920212223242526272829303132333435var chart2= Highcharts.chart('container1', &#123; chart: &#123; margin: [0, 0, 0, 0], width:300, padding:[0, 0, 0, 0], plotBackgroundColor: null, plotBorderWidth: null, plotShadow: false &#125;, title: &#123; text: '各航站异常行李数量' &#125;, /* tooltip: &#123; headerFormat: '&#123;series.name&#125;&lt;br&gt;', pointFormat: '&#123;point.name&#125;: &lt;b&gt;&#123;point.percentage:.1f&#125;%&lt;/b&gt;' &#125;,*/ plotOptions: &#123; pie: &#123; allowPointSelect: true, cursor: 'pointer', dataLabels: &#123; enabled: true, format: '&lt;b&gt;&#123;point.name&#125;&lt;/b&gt;', style: &#123; color: (Highcharts.theme &amp;&amp; Highcharts.theme.contrastTextColor) || 'black' &#125; &#125; &#125; &#125;, series: [&#123; type: 'pie', name: '异常行李量', data: [ ] &#125;] &#125;); 我的ajax请求 function getPieJson(){ var data1 = []; $.ajax({ type : “POST”, // 提交方式 url :servicefulPath + ‘/irregularBagReportTotal/pieChart’, success : function(result){ var json = result.data; for ( var key in json) { //通过遍历对象属性的方法，遍历键值对，获得key，然后通过 对象[key]获得对应的值 if (json.hasOwnProperty(key)) { data1.push([key, json[key]]); } } chart2.series[0].setData(data1); } }); } 四，后台代码格式（注明：每个的后台框架和条件都不一样，最重要的是返回一个map数据到前台就可以了） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//饼图 public Map&lt;String, Object&gt; pieChart()&#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); StringBuffer sql = new StringBuffer("SELECT SUM (E .LOSE) AS lose,SUM (E .MISSHIPMENT) AS miss,"); sql.append(" SUM (E .LEAKAGE_LUCK) AS leak,SUM (E . LESS) AS LESS,SUM (E .DAMAGED) AS damaged"); sql.append(" FROM E_ABNOM_BAGGA_TRAN E"); Query query = entityManager.createNativeQuery(sql.toString());//执行sql语句 Object[] o = (Object[])query.getResultList().get(0); IrregularBagReport count = new IrregularBagReport(); //丢失 if (o[0] == null) &#123; count.setLost(BigDecimal.ZERO); &#125; else &#123; count.setLost((BigDecimal) o[0]); &#125; //错运 if (o[1] == null) &#123; count.setMisshipMent(BigDecimal.ZERO); &#125; else &#123; count.setMisshipMent((BigDecimal) o[1]); &#125; //漏运 if (o[2] == null) &#123; count.setLeakageLuck(BigDecimal.ZERO); &#125; else &#123; count.setLeakageLuck((BigDecimal) o[2]); &#125; //少收 if (o[3] == null) &#123; count.setLess(BigDecimal.ZERO); &#125; else&#123; count.setLess( (BigDecimal) o[3]); &#125; //破损 if (o[4] == null) &#123; count.setDamaged(BigDecimal.ZERO); &#125; else &#123; count.setDamaged((BigDecimal) o[4]); &#125; map.put("丢失", count.getLost()); map.put("错运", count.getMisshipMent()); map.put("漏运",count.getLeakageLuck()); map.put("少收", count.getLess()); map.put("破损", count.getDamaged()); return map; &#125; 综上所述，按照上面的步骤就能生成饼图了，欢迎大佬们评论留言。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>easui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react+dva+antd的骚操作]]></title>
    <url>%2F2018%2F09%2F12%2Freact%2Bdva%2Bantd%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[前言：原谅我直接跳过react的基础，直接就讲react+dva的实际应用，因为直接从项目结构来讲，我觉得学习的成本更低，开发的速度更快，当然有时间的话还是建议冲react的基础学起。react的参考资料：建议先从React 入门实例教程开始学react的全家桶系列也不错 dva的参考资料：dva的官方指南有很多不错的脚手架ant design组合ant design UI可以说非常方便 例子实现效果 前提条件 确保 node 版本是 6.5 + 用 cnpm 或 yarn 能节约你安装依赖的时间 第一步：打开cmd，切换到你要安装的目录，使用npm安装dva-cli123$ npm i dva-cli@0.7 -g$ dva -v0.7.0 然后可以在命令行输入命令创建应用 12$ dva new user-dashboard$ cd user-dashboard 第二步，配置 antd 和 babel-plugin-importbabel-plugin-import 主要是用于按需引入 antd 的 JavaScript 和 CSS，这样打包出来的文件不至于太大。详情请看dva 12$ npm i antd --save$ npm i babel-plugin-import --save-dev 如果dva的版本是在0.7一下的话是没有.roadhogrc文件，修改 .roadhogrc，在 “extraBabelPlugins” 里加上，0.7一下的话是修改.webpackrc文件： 1["import", &#123; "libraryName": "antd", "style": "css" &#125;] 第三步，配置代理，能通过 RESTFul 的方式访问修改 .roadhogrc，加上 “proxy” 配置，或者修改.webpackrc文件也可：可以通过http://localhost:8000/api/users来查看json数据1234567"proxy": &#123; "/api": &#123; "target": "http://jsonplaceholder.typicode.com/", "changeOrigin": true, "pathRewrite": &#123; "^/api" : "" &#125; &#125;&#125;, 然后启动应用：可以新开一个命令行窗口 1$ npm start 然后系统就会自动在浏览器中打开页面，也可以访问http://localhost:8000/ 第四步，生成 users 路由 1dva g route users 输入这个命令就会在src的routes生成两个文件，一个User.js,一个是User.css，然后访问 http://localhost:8000/#/users 。 第五步，构造 users model 和 service同上，用dva的命令生成文件 1dva g model users 然后修改 src/models/users.js ： 1234567891011121314151617181920212223242526272829import * as usersService from '../services/users';export default &#123; namespace: 'users', state: &#123; list: [], total: null, &#125;, reducers: &#123; save(state, &#123; payload: &#123; data: list, total &#125; &#125;) &#123; return &#123; ...state, list, total &#125;; &#125;, &#125;, effects: &#123; *fetch(&#123; payload: &#123; page &#125; &#125;, &#123; call, put &#125;) &#123; const &#123; data, headers &#125; = yield call(usersService.fetch, &#123; page &#125;); yield put(&#123; type: 'save', payload: &#123; data, total: headers['x-total-count'] &#125; &#125;); &#125;, &#125;, subscriptions: &#123; setup(&#123; dispatch, history &#125;) &#123; return history.listen((&#123; pathname, query &#125;) =&gt; &#123; if (pathname === '/users') &#123; dispatch(&#123; type: 'fetch', payload: query &#125;); &#125; &#125;); &#125;, &#125;,&#125;; 在目标文件夹中新增 src/services/users.js： 12345import request from '../utils/request';export function fetch(&#123; page = 1 &#125;) &#123; return request(`/api/users?_page=$&#123;page&#125;&amp;_limit=5`);&#125; 由于我们需要从 response headers 中获取 total users 数量，所以需要改造下 src/utils/request.js： 12345678910111213141516171819202122232425262728293031323334353637import fetch from 'dva/fetch';function checkStatus(response) &#123; if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) &#123; return response; &#125; const error = new Error(response.statusText); error.response = response; throw error;&#125;/** * Requests a URL, returning a promise. * * @param &#123;string&#125; url The URL we want to request * @param &#123;object&#125; [options] The options we want to pass to "fetch" * @return &#123;object&#125; An object containing either "data" or "err" */export default async function request(url, options) &#123; const response = await fetch(url, options); checkStatus(response); const data = await response.json(); const ret = &#123; data, headers: &#123;&#125;, &#125;; if (response.headers.get('x-total-count')) &#123; ret.headers['x-total-count'] = response.headers.get('x-total-count'); &#125; return ret;&#125; 第六步，添加界面，让用户列表展现出来用 dva-cli 生成 component： 1$ dva g component Users/Users 然后修改生成出来的 src/components/Users/Users.js 和 src/components/Users/Users.css，并在 src/routes/Users.js 中引用他。User.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import React from 'react';import &#123; connect &#125; from 'dva';import &#123; Table, Pagination, Popconfirm, Button &#125; from 'antd';import &#123; routerRedux &#125; from 'dva/router';import styles from './Users.css';import &#123; PAGE_SIZE &#125; from '../../constants';import UserModal from './UserModal';function Users(&#123; dispatch, list: dataSource, loading, total, page: current &#125;) &#123; function deleteHandler(id) &#123; dispatch(&#123; type: 'users/remove', payload: id, &#125;); &#125; function editHandler(id, values) &#123; dispatch(&#123; type: 'users/patch', payload: &#123; id, values &#125;, &#125;); &#125; function pageChangeHandler(page) &#123; dispatch(routerRedux.push(&#123; pathname: '/users', query: &#123; page &#125;, &#125;)); &#125; function createHandler(values) &#123; dispatch(&#123; type: 'users/create', payload: values, &#125;); &#125; const columns = [ &#123; title: '姓名', dataIndex: 'name', key: 'name', render: text =&gt; &lt;a href=""&gt;&#123;text&#125;&lt;/a&gt;, &#125;, &#123; title: '邮箱', dataIndex: 'email', key: 'email', &#125;, &#123; title: '地址', dataIndex: 'website', key: 'website', &#125;, &#123; title: '操作', key: 'operation', render: (text, record) =&gt; ( &lt;span className=&#123;styles.operation&#125;&gt; &lt;UserModal record=&#123;record&#125; onOk=&#123;editHandler.bind(null, record.id)&#125;&gt; &lt;a&gt;修改&lt;/a&gt; &lt;/UserModal&gt; &lt;Popconfirm title="Confirm to delete?" onConfirm=&#123;deleteHandler.bind(null, record.id)&#125;&gt; &lt;a href=""&gt;删除&lt;/a&gt; &lt;/Popconfirm&gt; &lt;/span&gt; ), &#125;, ]; return ( &lt;div className=&#123;styles.normal&#125;&gt; &lt;div&gt; &lt;div className=&#123;styles.create&#125;&gt; &lt;UserModal record=&#123;&#123;&#125;&#125; onOk=&#123;createHandler&#125;&gt; &lt;Button type="primary"&gt;增加用户&lt;/Button&gt; &lt;/UserModal&gt; &lt;/div&gt; &lt;Table columns=&#123;columns&#125; dataSource=&#123;dataSource&#125; loading=&#123;loading&#125; rowKey=&#123;record =&gt; record.id&#125; pagination=&#123;false&#125; /&gt; &lt;Pagination className="ant-table-pagination" total=&#123;total&#125; current=&#123;current&#125; pageSize=&#123;PAGE_SIZE&#125; onChange=&#123;pageChangeHandler&#125; /&gt; &lt;/div&gt; &lt;/div&gt; );&#125;function mapStateToProps(state) &#123; const &#123; list, total, page &#125; = state.users; return &#123; loading: state.loading.models.users, list, total, page, &#125;;&#125;export default connect(mapStateToProps)(Users); User.css 123456789.normal &#123;&#125;.create &#123; margin-bottom: 1.5em;&#125;.operation a &#123; margin: 0 .5em;&#125; 这边主要是对 model 进行了微调，加入了 page 表示当前页由于 components 和 services 中都用到了 pageSize，所以提取到 src/constants.js改完后，切换到浏览器，应该能看到带分页的用户列表 第七步，添加 layout 添加 layout 布局，使得我们可以在首页和用户列表页之间来回切换。2.添加布局，src/components/MainLayout/MainLayout.js 和 CSS 文件在 src/routes 文件夹下的文件中引用这个布局 12345678910111213141516import React from 'react';import &#123; Router, Route &#125; from 'dva/router';import IndexPage from './routes/IndexPage';import Users from "./routes/Users.js";function RouterConfig(&#123; history &#125;) &#123; return ( &lt;Router history=&#123;history&#125;&gt; &lt;Route path="/" component=&#123;IndexPage&#125; /&gt; &lt;Route path="/users" component=&#123;Users&#125; /&gt; &lt;/Router&gt; );&#125;export default RouterConfig; 第八步，通过 dva-loading 处理 loading 状态dva 有一个管理 effects 执行的 hook，并基于此封装了 dva-loading 插件。通过这个插件，我们可以不必一遍遍地写 showLoading 和 hideLoading，当发起请求时，插件会自动设置数据里的 loading 状态为 true 或 false 。然后我们在渲染 components 时绑定并根据这个数据进行渲染。 先安装 dva-loading ： 1npm i dva-loading --save 修改 src/index.js 加载插件，在对应的地方加入下面两句： 12import createLoading from 'dva-loading';app.use(createLoading()); 然后在 src/components/Users/Users.js 里绑定 loading 数据： 1loading: state.loading.models.users, 具体参考这个 例子。 第九步，处理分页只改一个文件 src/components/Users/Users.js 就好。 处理分页有两个思路： 发 action，请求新的分页数据，保存到 model，然后自动更新页面 切换路由 (由于之前监听了路由变化，所以后续的事情会自动处理)我们用的是思路 2 的方式，好处是用户可以直接访问到 page 2 或其他页面。 参考这个 例子。 第10步，用户的修改，删除，增加都是对三个文件的操作 service, 修改 src/services/users.js： 123456789101112131415161718192021222324252627282930import request from '../utils/request';import &#123; PAGE_SIZE &#125; from '../constants';export function fetch(&#123; page &#125;) &#123; return request(`/api/users?_page=$&#123;page&#125;&amp;_limit=$&#123;PAGE_SIZE&#125;`); &#125; //删除export function remove(id) &#123; return request(`/api/users/$&#123;id&#125;`, &#123; method: 'DELETE', &#125;);&#125;//修改export function patch(id, values) &#123; return request(`/api/users/$&#123;id&#125;`, &#123; method: 'PATCH', body: JSON.stringify(values), headers: &#123; 'Content-Type': 'application/json', 'Accept': 'application/json', &#125;, &#125;);&#125;//新增export function create(values) &#123; return request('/api/users', &#123; method: 'POST', body: JSON.stringify(values), &#125;); &#125; model, 修改 src/models/users.js： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import * as usersService from '../services/users';export default &#123; namespace: 'users', state: &#123; list: [], total: null, page: null, &#125;, reducers: &#123; save(state, &#123; payload: &#123; data: list, total, page &#125; &#125;) &#123; return &#123; ...state, list, total, page &#125;; &#125;, &#125;, effects: &#123; //分页 *fetch(&#123; payload: &#123; page = 1 &#125; &#125;, &#123; call, put &#125;) &#123; const &#123; data, headers &#125; = yield call(usersService.fetch, &#123; page &#125;); yield put(&#123; type: 'save', payload: &#123; data, total: parseInt(headers['x-total-count'], 10), page: parseInt(page, 10), &#125;, &#125;); &#125;, //删除 *remove(&#123; payload: id &#125;, &#123; call, put &#125;) &#123; yield call(usersService.remove, id); yield put(&#123; type: 'reload' &#125;); &#125;, //修改*patch(&#123; payload: &#123; id, values &#125; &#125;, &#123; call, put &#125;) &#123; yield call(usersService.patch, id, values); yield put(&#123; type: 'reload' &#125;);&#125;,//新增*create(&#123; payload: values &#125;, &#123; call, put &#125;) &#123; yield call(usersService.create, values); yield put(&#123; type: 'reload' &#125;); &#125;, *reload(action, &#123; put, select &#125;) &#123; const page = yield select(state =&gt; state.users.page); yield put(&#123; type: 'fetch', payload: &#123; page &#125; &#125;); &#125;, &#125;, subscriptions: &#123; setup(&#123; dispatch, history &#125;) &#123; return history.listen((&#123; pathname, query &#125;) =&gt; &#123; if (pathname === '/users') &#123; dispatch(&#123; type: 'fetch', payload: query &#125;); &#125; &#125;); &#125;, &#125;,&#125;; component, 修改 src/components/Users/Users.js，替换 deleteHandler 内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import React from 'react';import &#123; connect &#125; from 'dva';import &#123; Table, Pagination, Popconfirm, Button &#125; from 'antd';import &#123; routerRedux &#125; from 'dva/router';import styles from './Users.css';import &#123; PAGE_SIZE &#125; from '../../constants';import UserModal from './UserModal';function Users(&#123; dispatch, list: dataSource, loading, total, page: current &#125;) &#123;//删除 function deleteHandler(id) &#123; dispatch(&#123; type: 'users/remove', payload: id, &#125;); &#125;//修改 function editHandler(id, values) &#123; dispatch(&#123; type: 'users/patch', payload: &#123; id, values &#125;, &#125;); &#125;//分页 function pageChangeHandler(page) &#123; dispatch(routerRedux.push(&#123; pathname: '/users', query: &#123; page &#125;, &#125;)); &#125;//新增 function createHandler(values) &#123; dispatch(&#123; type: 'users/create', payload: values, &#125;); &#125; const columns = [ &#123; title: '姓名', dataIndex: 'name', key: 'name', render: text =&gt; &lt;a href=""&gt;&#123;text&#125;&lt;/a&gt;, &#125;, &#123; title: '邮箱', dataIndex: 'email', key: 'email', &#125;, &#123; title: '地址', dataIndex: 'website', key: 'website', &#125;, &#123; title: '操作', key: 'operation', render: (text, record) =&gt; ( &lt;span className=&#123;styles.operation&#125;&gt; &lt;UserModal record=&#123;record&#125; onOk=&#123;editHandler.bind(null, record.id)&#125;&gt; &lt;a&gt;修改&lt;/a&gt; &lt;/UserModal&gt; &lt;Popconfirm title="Confirm to delete?" onConfirm=&#123;deleteHandler.bind(null, record.id)&#125;&gt; &lt;a href=""&gt;删除&lt;/a&gt; &lt;/Popconfirm&gt; &lt;/span&gt; ), &#125;, ]; return ( &lt;div className=&#123;styles.normal&#125;&gt; &lt;div&gt; &lt;div className=&#123;styles.create&#125;&gt; &lt;UserModal record=&#123;&#123;&#125;&#125; onOk=&#123;createHandler&#125;&gt; &lt;Button type="primary"&gt;增加用户&lt;/Button&gt; &lt;/UserModal&gt; &lt;/div&gt; &lt;Table columns=&#123;columns&#125; dataSource=&#123;dataSource&#125; loading=&#123;loading&#125; rowKey=&#123;record =&gt; record.id&#125; pagination=&#123;false&#125; /&gt; &lt;Pagination className="ant-table-pagination" total=&#123;total&#125; current=&#123;current&#125; pageSize=&#123;PAGE_SIZE&#125; onChange=&#123;pageChangeHandler&#125; /&gt; &lt;/div&gt; &lt;/div&gt; );&#125;function mapStateToProps(state) &#123; const &#123; list, total, page &#125; = state.users; return &#123; loading: state.loading.models.users, list, total, page, &#125;;&#125;export default connect(mapStateToProps)(Users); 以上就是react+dva+antd实现的一个简单的增删改的操作例子。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>and</tag>
        <tag>dva</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh框架整合之登录以及增删改查]]></title>
    <url>%2F2018%2F09%2F12%2Fssh%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[1.首先阐述一下我用得开发工具，myeclipse2017+oracle,所以我的基本配置步骤可能不一样，下面我用几张图来详解我的开发步骤。 —1先配置structs (Target 选择apache Tomcat (我的版本是8.0))接下来next 依然next,勾选复选框，把Core里面得第一个antlr-2.7.2.jar，因为这个包可能会和hibernate里面得一些包冲突 去掉之后选择下面的spring plus 勾上然后点finsh,然后structs 就配置好了 —2配置spring spring直接finsh —3hibernte配置 第二步，要选4.1，5.1不支持 第三部去掉create 复选框myeclipse会自动安排 然后之前我是已经创建了hibernate到oracle数据库的连接，所以我直接就next 如果hibernate没有连接自己的数据库，要先去配置连接，选择hibernate 然后点击myeclipse derby去新建连接 （最后注意一下在配置安装hibernate之前最好先建一个包用来存放数据库表的pojo类） 二.基本配置好了之后，接下来就是具体的事物了 1.编写Dao接口 2.编写完接口之后，再来写接口的实现类 三.写service接口，和dao 接口是一样的复制过来就行，我就不上图了 四.service接口实现类 接口实现类里面调用方法即可 五.hibernate核心配置文件是applicationContext.xml如果成功配置数据库会直接在src里生成，并映射好数据库表以及连接池，这里面要配置的主要是action，service，dao，spring管理hibernate,定义事务管理器 ，以及事物管理机制，最后aop切面类 这里一定要对应自己的包名，然后是structs配置（structs主要是控制跳转，接受来之action类里面的值然后传输到页面） 六.是我的jsp页面 1.登录页面 首页 最后总结一下吧！ssh学习的新手，开发过程中困难重重，遇到了不少问题，花了不少时间，不过也确实学到了不少东西，页面排版不太好，请多多理解，如果有什么纰漏和错误也希望大家给予指出，有问题可以留言。]]></content>
      <categories>
        <category>框架</category>
        <category>ssh</category>
      </categories>
      <tags>
        <tag>ssh框架整合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Datatables复选框问题]]></title>
    <url>%2F2018%2F09%2F12%2FDatatables%E5%A4%8D%E9%80%89%E6%A1%86%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[关于datatables复选框全选一开始接触到datatables感觉挺坑的，文档少，例子少又不全，遇到了不少问题，希望跟我遇到同样问题的人都可以少走弯路。官方api文档不同的封装方法操作也有点不同页面html12&lt;table class="table table-bordered table-striped" id="productTable"&gt; &lt;/table&gt; js12/*初始化表格*/var catalogTable = loadProduct(); 12345678910$('#productTable').on('click', '.all-select', function (e) &#123; var check = $(catalogTable.rows).find(".csel"); if ($(this).is(":checked")) &#123; $("tr").toggleClass('selected'); check.prop("checked", true); &#125; else &#123; $(this).toggleClass('selected'); check.prop("checked", false); &#125;&#125;); 这段代码主第一行的意思是当单击表格的标题行类名为all-select的复选框时触发事件，操作时换成自己的类名就行了。第二行是获取表格类名为cesl的行,当复选框选中时为ture，没选中为false，就可以实现全选功能。关于这方面的问题都可以问我，欢迎留言]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>dataables</tag>
        <tag>EasyUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsp+servlet实现模糊查询和分页效果]]></title>
    <url>%2F2018%2F09%2F12%2Fjsp%2F</url>
    <content type="text"><![CDATA[1.DAO+MVC包 2.DAO接口方法定义 123456789101112131415161718192021222324252627282930package com.wanczy.dao;import java.math.BigDecimal;import java.util.List;import com.wanczy.pojo.CustomerResourcePOJO;public interface CustomerResourceDAO &#123; /** * * @param sName学校名称 * @param cLevel合作等级 * @param cState合作状态 * @param pageSize一页显示数据的笔数 * @param pageCurrent显示的页数 * @return */ //根据名字水平状态来查询数据，传入页数及当前页数 public List&lt;CustomerResourcePOJO&gt; findByNameLevelState (String sName,int cLevel,int cState,int pageSize,int pageCurrent); //查询数据笔数 public int findCountByNameLevelState(String sName,int cLevel,int cState); //查询单笔数据 public CustomerResourcePOJO findByCId(BigDecimal cID); //修改 public boolean doUpd(CustomerResourcePOJO pojo); //新增 public boolean doIns(CustomerResourcePOJO pojo); //删除 public boolean doDel(BigDecimal cID);&#125; 3.DAO接口方法实现方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236package com.wanczy.dao.impl;import java.math.BigDecimal;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.util.ArrayList;import java.util.List;import com.wanczy.dao.CustomerResourceDAO;import com.wanczy.pojo.CustomerResourcePOJO;public class CustomerResourceDAOImpl implements CustomerResourceDAO &#123; Connection conn ; public CustomerResourceDAOImpl(Connection conn)&#123; this.conn = conn; &#125; public boolean doDel(BigDecimal cID) &#123; boolean flag = false; PreparedStatement pstate = null; try &#123; this.conn.setAutoCommit(false); String sql = "delete from customer_resource where c_id = ?"; pstate = this.conn.prepareStatement(sql); pstate.setBigDecimal(1, cID); pstate.execute();//执行 this.conn.commit(); flag = true; &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; this.conn.rollback(); &#125; catch (Exception e2) &#123; e2.printStackTrace(); // TODO: handle exception &#125; // TODO: handle exception &#125; finally&#123; try &#123; pstate.close(); &#125; catch (Exception e2) &#123; e2.printStackTrace(); // TODO: handle exception &#125; &#125; return flag; &#125; public boolean doIns(CustomerResourcePOJO pojo) &#123; boolean flag = false; PreparedStatement pstate = null; try &#123; this.conn.setAutoCommit(false); String sql = "insert into customer_resource (c_id, s_name, s_add, " + "s_link_man, s_link_tel, c_level, c_state ,s_leader, s_leader_tel)" + "values(scott_squence.nextval,?,?,?,?,?,?,?,?)"; pstate = this.conn.prepareStatement(sql); pstate.setString(1,pojo.getSname()); pstate.setString(2,pojo.getSadd()); pstate.setString(3,pojo.getSlinkMan()); pstate.setString(4,pojo.getSlinkTel()); pstate.setInt(5,pojo.getClevel()); pstate.setInt(6,pojo.getCstate()); pstate.setString(7,pojo.getSleader()); pstate.setString(8,pojo.getSleaderTel()); pstate.execute();//执行 this.conn.commit(); flag = true; &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; this.conn.rollback(); &#125; catch (Exception e2) &#123; e2.printStackTrace(); // TODO: handle exception &#125; // TODO: handle exception &#125; finally&#123; try &#123; pstate.close(); &#125; catch (Exception e2) &#123; e2.printStackTrace(); // TODO: handle exception &#125; &#125; return flag; &#125; public boolean doUpd(CustomerResourcePOJO pojo) &#123; boolean flag = false; PreparedStatement pstate = null; try &#123; this.conn.setAutoCommit(false); String sql = "update customer_resource set s_name=?, s_add=?, " + " s_link_man=?, s_link_tel=?, c_level=?, c_state=? ,s_leader=?, s_leader_tel=? where" + " c_id = ?"; pstate = this.conn.prepareStatement(sql); pstate.setString(1,pojo.getSname()); pstate.setString(2,pojo.getSadd()); pstate.setString(3,pojo.getSlinkMan()); pstate.setString(4,pojo.getSlinkTel()); pstate.setInt(5,pojo.getClevel()); pstate.setInt(6,pojo.getCstate()); pstate.setString(7,pojo.getSleader()); pstate.setString(8,pojo.getSleaderTel()); pstate.setBigDecimal(9, pojo.getCid()); pstate.execute();//执行 this.conn.commit(); flag = true; &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; this.conn.rollback(); &#125; catch (Exception e2) &#123; e2.printStackTrace(); // TODO: handle exception &#125; // TODO: handle exception &#125; finally&#123; try &#123; pstate.close(); &#125; catch (Exception e2) &#123; e2.printStackTrace(); // TODO: handle exception &#125; &#125; return flag; &#125; public CustomerResourcePOJO findByCId(BigDecimal cID) &#123; CustomerResourcePOJO pojo = null; PreparedStatement pstate = null; ResultSet res = null; try &#123; String sql = "select s_name, s_add, " + "s_link_man, s_link_tel, c_level, c_state ,s_leader, s_leader_tel from customer_resource where c_id = ?"; pstate = this.conn.prepareStatement(sql); pstate.setBigDecimal(1, cID); res = pstate.executeQuery(); while(res.next())&#123; pojo = new CustomerResourcePOJO(cID,res.getString(1),res.getString(2), res.getString(3),res.getString(4),res.getInt(5),res.getInt(6), res.getString(7),res.getString(8)); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); // TODO: handle exception &#125; finally&#123; try &#123; res.close(); pstate.close(); &#125; catch (Exception e2) &#123; e2.printStackTrace(); &#125; &#125; return pojo; &#125; public List&lt;CustomerResourcePOJO&gt; findByNameLevelState(String sName, int cLevel, int cState, int pageSize, int pageCurrent) &#123; List&lt;CustomerResourcePOJO&gt; list = new ArrayList&lt;CustomerResourcePOJO&gt;(); PreparedStatement pstate = null; ResultSet res = null; try &#123; StringBuffer sql = new StringBuffer(); sql.append("select c_id,s_name, s_add, s_link_man, "+ " s_link_tel, c_level, c_state ,s_leader, "+ " s_leader_tel from (select c_id,s_name, s_add, s_link_man, "+ " s_link_tel, c_level, c_state ,s_leader, "+ " s_leader_tel ,rownum abc "+ " from customer_resource where s_name like ? "); if(cLevel != 0)&#123; sql.append(" and c_level = "+cLevel); &#125; if(cState != 0)&#123; sql.append(" and c_state = "+cState); &#125; sql.append(" ) where abc&gt;? and abc&lt;=? order by c_level,c_state"); pstate = this.conn.prepareStatement(sql.toString()); pstate.setString(1, "%"+sName+"%"); pstate.setInt(2, (pageCurrent-1)*pageSize); pstate.setInt(3, pageCurrent*pageSize); res = pstate.executeQuery(); while(res.next())&#123; CustomerResourcePOJO pojo = new CustomerResourcePOJO(res.getBigDecimal(1),res.getString(2),res.getString(3), res.getString(4),res.getString(5),res.getInt(6),res.getInt(7), res.getString(8),res.getString(9)); list.add(pojo); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); // TODO: handle exception &#125; finally&#123; try &#123; res.close(); pstate.close(); &#125; catch (Exception e2) &#123; e2.printStackTrace(); &#125; &#125; return list; &#125;//查询单笔数据 public int findCountByNameLevelState(String sName, int cLevel, int cState) &#123; int count = 0; PreparedStatement pstate = null; ResultSet res = null; try &#123; StringBuffer sql = new StringBuffer(); sql.append("select count(c_id) from customer_resource where s_name like ? "); if(cLevel != 0)&#123; sql.append(" and c_level = "+cLevel); &#125; if(cState != 0)&#123; sql.append(" and c_state = "+cState); &#125; pstate = this.conn.prepareStatement(sql.toString()); pstate.setString(1, "%"+sName+"%"); res = pstate.executeQuery(); while(res.next())&#123; count = res.getInt(1); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); // TODO: handle exception &#125; finally&#123; try &#123; res.close(); pstate.close(); &#125; catch (Exception e2) &#123; e2.printStackTrace(); &#125; &#125; return 4.Pojo实体类（数据库里的字段） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package com.wanczy.pojo;import java.io.Serializable;import java.math.BigDecimal;public class CustomerResourcePOJO implements Serializable &#123; private BigDecimal cid; private String sname; private String sadd; private String slinkMan; private String slinkTel; private int clevel; private int cstate; private String sleader; private String sleaderTel; public BigDecimal getCid() &#123; return cid; &#125; public void setCid(BigDecimal cid) &#123; this.cid = cid; &#125; public String getSname() &#123; return sname; &#125; public void setSname(String sname) &#123; this.sname = sname; &#125; public String getSadd() &#123; return sadd; &#125; public void setSadd(String sadd) &#123; this.sadd = sadd; &#125; public String getSlinkMan() &#123; return slinkMan; &#125; public void setSlinkMan(String slinkMan) &#123; this.slinkMan = slinkMan; &#125; public String getSlinkTel() &#123; return slinkTel; &#125; public void setSlinkTel(String slinkTel) &#123; this.slinkTel = slinkTel; &#125; public int getClevel() &#123; return clevel; &#125; public void setClevel(int clevel) &#123; this.clevel = clevel; &#125; public int getCstate() &#123; return cstate; &#125; public void setCstate(int cstate) &#123; this.cstate = cstate; &#125; public String getSleader() &#123; return sleader; &#125; public void setSleader(String sleader) &#123; this.sleader = sleader; &#125; public String getSleaderTel() &#123; return sleaderTel; &#125; public void setSleaderTel(String sleaderTel) &#123; this.sleaderTel = sleaderTel; &#125; //一般构造方法都要写一个带id和一个不带id的，还有一个无参的，方便后面的增删改查以及方法的调用 public CustomerResourcePOJO(BigDecimal cid, String sname, String sadd, String slinkMan, String slinkTel, int clevel, int cstate, String sleader, String sleaderTel) &#123; super(); this.cid = cid; this.sname = sname; this.sadd = sadd; this.slinkMan = slinkMan; this.slinkTel = slinkTel; this.clevel = clevel; this.cstate = cstate; this.sleader = sleader; this.sleaderTel = sleaderTel; &#125; public CustomerResourcePOJO( String sname, String sadd, String slinkMan, String slinkTel, int clevel, int cstate, String sleader, String sleaderTel) &#123; super(); this.sname = sname; this.sadd = sadd; this.slinkMan = slinkMan; this.slinkTel = slinkTel; this.clevel = clevel; this.cstate = cstate; this.sleader = sleader; this.sleaderTel = sleaderTel; &#125; public CustomerResourcePOJO() &#123; super(); &#125; &#125; 5.代理类以及工厂类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.wanczy.dao.proxy;import java.math.BigDecimal;import java.sql.Connection;import java.util.List;import com.wanczy.dao.CustomerResourceDAO;import com.wanczy.dao.impl.CustomerResourceDAOImpl;import com.wanczy.pojo.CustomerResourcePOJO;import com.wanczy.pub.GetConnection;public class CustomerResourceDAOProxy implements CustomerResourceDAO &#123; Connection conn = null; CustomerResourceDAOImpl impl = null; public CustomerResourceDAOProxy()&#123; try &#123; this.conn = GetConnection.getConn(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; this.impl = new CustomerResourceDAOImpl(this.conn); &#125; public boolean doDel(BigDecimal cID) &#123; boolean flag = this.impl.doDel(cID); this.close(); return flag; &#125; public boolean doIns(CustomerResourcePOJO pojo) &#123; boolean flag = this.impl.doIns(pojo); this.close(); return flag; &#125; public boolean doUpd(CustomerResourcePOJO pojo) &#123; boolean flag = this.impl.doUpd(pojo); this.close(); return flag; &#125; public CustomerResourcePOJO findByCId(BigDecimal cID) &#123; CustomerResourcePOJO pojo = this.impl.findByCId(cID); this.close(); return pojo; &#125; public List&lt;CustomerResourcePOJO&gt; findByNameLevelState(String sName, int cLevel, int cState, int pageSize, int pageCurrent) &#123; List&lt;CustomerResourcePOJO&gt; list = this.impl.findByNameLevelState(sName, cLevel, cState, pageSize, pageCurrent); this.close(); return list; &#125; public int findCountByNameLevelState(String sName, int cLevel, int cState) &#123; int count = this.impl.findCountByNameLevelState(sName, cLevel, cState); this.close(); return count; &#125; public void close()&#123; try &#123; this.conn.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 6.servlet 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.wanczy.servlet.customerResource;import java.io.IOException;import java.io.PrintWriter;import java.util.List;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.wanczy.dao.factory.CustomerResourceDAOFactory;import com.wanczy.pojo.CustomerResourcePOJO;public class CustomerResourceQuery extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding("utf-8"); response.setCharacterEncoding("utf-8"); response.setContentType("text/html; charset=utf-8"); String sName = request.getParameter("sName"); int cLevel = Integer.parseInt(request.getParameter("cLevel")); int cState = Integer.parseInt(request.getParameter("cState")); int pageSize = Integer.parseInt(request.getParameter("pageSize")); int pageCurrent = Integer.parseInt(request.getParameter("pageCurrent")); List&lt;CustomerResourcePOJO&gt; list = CustomerResourceDAOFactory.getDAOInstance().findByNameLevelState(sName, cLevel, cState, pageSize, pageCurrent); int count = CustomerResourceDAOFactory.getDAOInstance().findCountByNameLevelState(sName, cLevel, cState); PrintWriter out = response.getWriter(); StringBuffer sb = new StringBuffer(); sb.append("&lt;input type='hidden' id='count' value='"+count+"'/&gt;"); sb.append("&lt;table id='sample_1' class='table table-striped table-bordered table-hover table-checkable order-column'&gt;&lt;tr&gt;&lt;th&gt;学校名称&lt;/th&gt;&lt;th&gt;学校地址&lt;/th&gt;&lt;th&gt;联系人&lt;/th&gt;&lt;th&gt;联系人电话&lt;/th&gt;&lt;th&gt;客户等级&lt;/th&gt;&lt;th&gt;合作状态&lt;/th&gt;&lt;th&gt;院校领导&lt;/th&gt;&lt;th&gt;领导电话&lt;/th&gt;&lt;th&gt;操作&lt;/th&gt;&lt;/tr&gt;"); for(CustomerResourcePOJO pojo : list)&#123; String cLevelCode = ""; if(pojo.getClevel() == 1)&#123; cLevelCode = "高"; &#125;else if(pojo.getClevel() == 2)&#123; cLevelCode = "中"; &#125;else&#123; cLevelCode = "低"; &#125; String cStateCode = ""; if(pojo.getCstate() == 1)&#123; cStateCode = "常年合作"; &#125;else if(pojo.getCstate() == 2)&#123; cStateCode = "合作少"; &#125;else&#123; cStateCode = "近年无合作"; &#125; sb.append("&lt;tr&gt;" + "&lt;td&gt;"+pojo.getSname()+"&lt;/td&gt;" + "&lt;td&gt;"+pojo.getSadd()+"&lt;/td&gt;" + "&lt;td&gt;"+pojo.getSlinkMan()+"&lt;/td&gt;" + "&lt;td&gt;"+pojo.getSlinkTel()+"&lt;/td&gt;" + "&lt;td&gt;"+cLevelCode+"&lt;/td&gt;" + "&lt;td&gt;"+cStateCode+"&lt;/td&gt;" + "&lt;td&gt;"+pojo.getSleader()+"&lt;/td&gt;" + "&lt;td&gt;"+pojo.getSleaderTel()+"&lt;/td&gt;" + "&lt;td&gt;&lt;a href='#' onclick='goUpdate("+pojo.getCid()+")'&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;" + "&lt;a href='#' onclick='goDelete("+pojo.getCid()+")'&gt;删除&lt;/a&gt;&lt;/td&gt;" + "&lt;/tr&gt;"); &#125; sb.append("&lt;/table&gt;"); out.print(sb.toString()); out.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 7.web页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134&lt;%@page contentType="text/html; charset=utf-8" %&gt; &lt;% String path=request.getContextPath(); %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;分页操作&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form name = "f"&gt; &lt;fieldset title="查询"&gt; &lt;legend&gt; &lt;span width="12%" height="25" class="STYLE1" style="color: black;"&gt;查询条件&lt;/span&gt; &lt;/legend&gt; 学校名称：&lt;input type="text" name="sName"/&gt; 合作等级：&lt;select name="cLevel"&gt; &lt;option value="0" selected="selected"&gt;全部&lt;/option&gt; &lt;option value="1"&gt;高&lt;/option&gt; &lt;option value="2"&gt;中&lt;/option&gt; &lt;option value="3"&gt;低&lt;/option&gt; &lt;/select&gt; 合作状态：&lt;select name="cState"&gt; &lt;option value="0" selected="selected"&gt;全部&lt;/option&gt; &lt;option value="1"&gt;常年合作&lt;/option&gt; &lt;option value="2"&gt;合作少&lt;/option&gt; &lt;option value="3"&gt;近年无合作&lt;/option&gt; &lt;/select&gt; &lt;input type="button" value="查询" onclick="query(0)"/&gt; &lt;input type="button" value="新增" onclick="goAdd()"/&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;hr/&gt; &lt;div id="showTable"&gt;&lt;/div&gt; &lt;div align="right"&gt; &lt;input type="button" id="first" value="|&lt;" onclick="query(1)"/&gt; &lt;input type="button" id="up" value="&lt;" onclick="query(2)"/&gt; &lt;input type="button" id="next" value="&gt;" onclick="query(3)"/&gt; &lt;input type="button" id="end" value="&gt;|" onclick="query(4)"/&gt; &lt;select id="selectPageCurrent" onchange="query(5)"&gt; &lt;option value="3" selected="selected"&gt;显示3笔&lt;/option&gt; &lt;option value="5"&gt;显示5笔&lt;/option&gt; &lt;option value="10"&gt;显示10笔&lt;/option&gt; &lt;/select&gt; &lt;span id="showPageMessage"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type="text/javascript"&gt; var pageSize = 3;//一页显示的数据笔数 var pageCurrent = 1;//显示的页数 var allCount = 0;//总共的数据笔数 var allPage = 0;//总共数据页数 query(0); function query(num)&#123; var sName = f.sName.value; var cLevel = f.cLevel.value; var cState = f.cState.value; if(num == 1)&#123; pageCurrent = 1; &#125;else if(num == 2)&#123; pageCurrent = pageCurrent -1; &#125;else if(num == 3)&#123; pageCurrent = pageCurrent + 1; &#125;else if(num == 4)&#123; pageCurrent = allPage; &#125;else if(num == 5)&#123; pageCurrent = 1; pageSize = $("#selectPageCurrent").val();//取得每页显示的数据笔数 &#125; $(document).ready(function()&#123; //设置提交的路径，和参数 $.post("&lt;%=path %&gt;/CustomerResourceQuery",&#123;"sName":sName,"cLevel":cLevel,"cState":cState,"pageSize":pageSize,"pageCurrent":pageCurrent&#125;, function(data)&#123;//Servlet执行完之后执行方法，data表示的servlet返回数据内容 $("#showTable").html(data);//显示Servlet返回的内容 controlButton(); &#125;); &#125;); &#125; function controlButton()&#123; allCount = $("#count").val(); if(allCount%pageSize == 0)&#123; allPage = allCount/pageSize &#125;else&#123; allPage = Math.floor(allCount/pageSize) +1; &#125; document.getElementById("first").disabled = false; document.getElementById("up").disabled = false; document.getElementById("next").disabled = false; document.getElementById("end").disabled = false; if(allPage == 1)&#123; document.getElementById("first").disabled = true; document.getElementById("up").disabled = true; document.getElementById("next").disabled = true; document.getElementById("end").disabled = true; &#125;else if(pageCurrent == 1)&#123; document.getElementById("first").disabled = true; document.getElementById("up").disabled = true; &#125;else if(pageCurrent == allPage)&#123; document.getElementById("next").disabled = true; document.getElementById("end").disabled = true; &#125; $("#showPageMessage").html("总共"+allCount+"笔数据，当前显示"+pageCurrent+"页，共"+ allPage+"页"); &#125; function goAdd()&#123; var width = window.screen.width ; var height = window.screen.height ; window.open("add.jsp","新增客户",'height=400,width=300,top='+(height-450)/2+',left='+(width-300)/2+',toolbar=no,menubar=no,scrollbars=no, resizable=no,location=no, status=no'); &#125; function goUpdate(cID)&#123; var width = window.screen.width ; var height = window.screen.height ; window.open("&lt;%=path%&gt;/CustomerResourceFindByCID?cID="+cID,"修改客户",'height=400,width=300,top='+(height-450)/2+',left='+(width-300)/2+',toolbar=no,menubar=no,scrollbars=no, resizable=no,location=no, status=no'); &#125; function goDelete(cID)&#123; if(confirm("确认删除？"))&#123; $(document).ready(function()&#123; //设置提交的路径，和参数 $.post("&lt;%=path %&gt;/CustomerResourceDel",&#123;"cId":cID&#125;, function(data)&#123;//Servlet执行完之后执行方法，data表示的servlet返回数据内容 if(data == "true")&#123; alert("删除成功"); query(0); &#125;else&#123; alert("删除失败，请联系系统管理员"); &#125; &#125;); &#125;); &#125; &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; (本人亲测可以） 8.页面实现效果展示 总结一下吧，mvc+dao设计模式的好处就是实现了java面向对象的思想，接口和方法的实现分开，便于后期的开发和维护，以及功能的增加，通过接口实现类去实现接口中的方法，通过代理类去取得数据库连接池文件及调用方法，有问题可以留言。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jsp</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在服务器的tomcat上部署多个项目]]></title>
    <url>%2F2018%2F09%2F12%2Ftomcat%2F</url>
    <content type="text"><![CDATA[第一步，找到服务器上tomcat的配置文件conf/server.xml文件。类似于我上面的这个文件，找到server.xml里面的 标签，在 标签后面加入如下配置 1234567891011121314151617181920212223242526272829303132&lt;Service name="Catalina2"&gt; &lt;!-- service的名字要对应 --&gt; &lt;Connector port="8099" protocol="HTTP/1.1" &lt;!--端口号与上面一个Service的端口号不一样--&gt; connectionTimeout="20000" redirectPort="8443" URIEncoding="UTF-8"/&gt; &lt;Engine name="Catalina2" defaultHost="localhost"&gt; &lt;!-- service的名字 --&gt; &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm" resourceName="UserDatabase"/&gt; &lt;Host name="localhost" appBase="webapps2" unpackWARs="true" autoDeploy="true" xmlValidation="false" xmlNamespaceAware="false"&gt; &lt;Context path="" docBase="D:\devsoft\apache-tomcat-8.0.35\webapps2\xiaolumouth" reloadable="true" workDir="D:/temp/Tomcat/test" debug="0"/&gt; &lt;/Host&gt; &lt;!-- docBase 是第二个项目的路径--&gt; &lt;/Engine&gt; &lt;/Service&gt; 第二步，复制webapps目录，复制后改变文件名例如webapps2 把另外一个你要跑的项目放在目录webapps2下，在servicexml里面吧docBase属性引向该目录，是你自己的tomcat里面webapps2里面项目的路径就可以了。]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五分钟搭建个人博客]]></title>
    <url>%2F2018%2F07%2F03%2FFirstBlog%2F</url>
    <content type="text"><![CDATA[三步完成个人博客搭建， 这是一篇小白也能看懂的文章，本文主要针对mac OS ，Windows 除了软件安装方式和命令有些区别（装了git bash也一样），其他基本一样。你可能会经常看到类似于这样的博客： 好了，下面开始我们的装逼之路。 1.创建github域名和空间1.1注册首先你需要注册一个Github账号，已有的可以下翻去1.2 创建仓库，注意username，这会影响到你的域名，你的域名将会是 username.github.io ，所以认真的取个名字吧。 （注册需要邮箱激活） 创建仓库然后需要创建一个仓库(repository) 来存储我们的网站，点击首页任意位置出现的 New repository按钮创建仓库, Respository name 中的username.github.io 的username 一定与前面的Owner 一致，记住你的username下面会用到。 2.安装Hexo 可以说是目前最流行的博客框架了，基于Nodejs，更多信息可以google，下面需要安装的工具包括 Git，Nodejs，Hexo。 2.1安装git $ brew install git //安装git https://sourceforge.net/projects/git-osx-installer/可以通过该网址进行安装 2.2 安装node.js先安装nvm，这是Nodejs版本管理器，可以轻松切换Nodejs版本。 这里有两种方式安装。如果使用curl的方式安装，安装完成之后一定要重启终端。1.Homebrew 安装方式，此安装方式无需重启 $ brew install nvm $ mkdir ~/.nvm $ export NVM_DIR=~/.nvm $ . $(brew --prefix nvm)/nvm.sh 安装完成后，重启终端 并执行下列命令即可安装 Node.js。 2.3安装Hexo以上所有都安装完成之后再安装Hexo$ sudo npm install hexo-cli -g 工具安装完成之后，上传到Github上 3.编写，发布接下来我们需要用Hexo初始化一个博客，然后更改一些自定义的配置，或者加上自己喜欢的主题，写上第一篇文章，然后发布到自己的个人Github网站(username.github.io)。 3.1创建博客将下面的 username 替换成你自己的username，执行成功后，会创建出一个名为 username.github.io 的文件夹。 $ hexo init username.github.io 3.2更改配置主题安装 为了使博客不太难看，我们需要安装一个主题，切换至刚刚生成的Hexo 目录，安装主题 `$ cd username.github.io` `$ git clone https://github.com/iissnan/hexo-theme-next themes/next` 这里选了一个极简的主题，也是Hexo众多主题中最受欢迎的一个。上面出现的喵神的主题 在这里。Hexo也有更多主题供你选择。基础配置：打开文件位置username.github.io/_config.yml修改几个键值对，下面把几个必须设置的列出来按需求修改，记得保存， 还有注意配置的键值之间一定要有空格。更多设置… title: dimsky 的 9 维空间 //你博客的名字 author: dimsky //你的名字 language: zh-Hans //语言 中文 theme: next //刚刚安装的主题名称 deploy:type: git //使用Git 发布 repo: https://github.com/username/username.github.io.git // 刚创建的Github仓库 主题配置： 主题配置文件在username.github.io/themes/next/_config.yml中修改，这里略过。设置详情 3.3写文章所有基础框架都已经创建完成，接下来可以开始写你的第一篇博客了在username.github.io/source/_posts下创建你的第一个博客吧，例如，创建一个名为FirstBlog.md的文件，用Markdown大肆发挥吧，注意保存。 3.4测试$ hexo s测试服务启动，你可以在浏览器中输入https://localhost:4000 访问了。 3.5 安装hexo-deployer-git自动部署发布工具$ npm install hexo-deployer-git –save 3.6 发布测试没问题后，我们就生成静态网页文件发布至我们的Github pages 中。$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 最后直接在浏览器里访问你的github的域名就可以你个人博客了]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
</search>
