<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot实现Restful服务，基于HTTP-JSON传输]]></title>
    <url>%2F2018%2F12%2F19%2FSpringBoot%E5%AE%9E%E7%8E%B0Restful%E6%9C%8D%E5%8A%A1%EF%BC%8C%E5%9F%BA%E4%BA%8EHTTP-JSON%E4%BC%A0%E8%BE%93%2F</url>
    <content type="text"><![CDATA[一，数据库准备1）创建数据库 1CREATE DATABASE springbootdb; 2）创建表 12345678DROP TABLE IF EXISTS `city`;CREATE TABLE `city` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '城市编号', `province_id` int(10) unsigned NOT NULL COMMENT '省份编号', `city_name` varchar(25) DEFAULT NULL COMMENT '城市名称', `description` varchar(25) DEFAULT NULL COMMENT '描述', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 3）插入数据 1INSERT city VALUES (1001 ,110,'福建','今天很开心'); 二，项目结构 项目结构解读 controller控制层 dao接口层 domain实体类 service业务逻辑接口类 service impl 业务逻辑实现类 application.properties 应用配置文件，应用启动会自动读取配置 代码实现 实体层 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 城市实体类 * * Created by ws on 10/12/2018. * */public class City &#123; /** * 城市编号 */ private Long id; /** * 省份编号 */ private Long provinceId; /** * 城市名称 */ private String cityName; /** * 描述 */ private String description; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public Long getProvinceId() &#123; return provinceId; &#125; public void setProvinceId(Long provinceId) &#123; this.provinceId = provinceId; &#125; public String getCityName() &#123; return cityName; &#125; public void setCityName(String cityName) &#123; this.cityName = cityName; &#125; public String getDescription() &#123; return description; &#125; public void setDescription(String description) &#123; this.description = description; &#125;&#125; 接口层 12345678910111213141516171819202122232425262728/** * 城市 DAO 接口类 * *Created by ws on 10/12/2018. */public interface CityDao &#123; /** * 获取城市信息列表 * * @return */ List&lt;City&gt; findAllCity(); /** * 根据城市 ID，获取城市信息 * * @param id * @return */ City findById(@Param("id") Long id); Long saveCity(City city); Long updateCity(City city); Long deleteCity(Long id);&#125; 接口对应的mapper层 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="org.spring.springboot.dao.CityDao"&gt; &lt;resultMap id="BaseResultMap" type="org.spring.springboot.domain.City"&gt; &lt;result column="id" property="id" /&gt; &lt;result column="province_id" property="provinceId" /&gt; &lt;result column="city_name" property="cityName" /&gt; &lt;result column="description" property="description" /&gt; &lt;/resultMap&gt; &lt;parameterMap id="City" type="org.spring.springboot.domain.City"/&gt; &lt;sql id="Base_Column_List"&gt; id, province_id, city_name, description &lt;/sql&gt; &lt;select id="findById" resultMap="BaseResultMap" parameterType="java.lang.Long"&gt; select &lt;include refid="Base_Column_List" /&gt; from city where id = #&#123;id&#125; &lt;/select&gt; &lt;select id="findAllCity" resultMap="BaseResultMap" &gt; select &lt;include refid="Base_Column_List" /&gt; from city &lt;/select&gt; &lt;insert id="saveCity" parameterMap="City" useGeneratedKeys="true" keyProperty="id"&gt; insert into city(id,province_id,city_name,description) values (#&#123;id&#125;,#&#123;provinceId&#125;,#&#123;cityName&#125;,#&#123;description&#125;) &lt;/insert&gt; &lt;update id="updateCity" parameterMap="City"&gt; update city set &lt;if test="provinceId!=null"&gt; province_id = #&#123;provinceId&#125;, &lt;/if&gt; &lt;if test="cityName!=null"&gt; city_name = #&#123;cityName&#125;, &lt;/if&gt; &lt;if test="description!=null"&gt; description = #&#123;description&#125; &lt;/if&gt; where id = #&#123;id&#125; &lt;/update&gt; &lt;delete id="deleteCity" parameterType="java.lang.Long"&gt; delete from city where id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 业务逻辑接口层 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 城市业务逻辑接口类 * * Created by ws on 10/12/2018. */public interface CityService &#123; /** * 获取城市信息列表 * * @return */ List&lt;City&gt; findAllCity(); /** * 根据城市 ID,查询城市信息 * * @param id * @return */ City findCityById(Long id); /** * 新增城市信息 * * @param city * @return */ Long saveCity(City city); /** * 更新城市信息 * * @param city * @return */ Long updateCity(City city); /** * 根据城市 ID,删除城市信息 * * @param id * @return */ Long deleteCity(Long id);&#125; 业务逻辑接口实现类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 城市业务逻辑实现类 * * Created by ws on 10/12/2018. */@Servicepublic class CityServiceImpl implements CityService &#123; @Autowired private CityDao cityDao; /** * 查询所有 * @return */ public List&lt;City&gt; findAllCity()&#123; return cityDao.findAllCity(); &#125; /** * 根据id查找相关 * @param id * @return */ public City findCityById(Long id) &#123; return cityDao.findById(id); &#125; /** * 新增 * @param city * @return */ @Override public Long saveCity(City city) &#123; return cityDao.saveCity(city); &#125; /** *修改 * @param city * @return */ @Override public Long updateCity(City city) &#123; return cityDao.updateCity(city); &#125; /** * 删除 * @param id * @return */ @Override public Long deleteCity(Long id) &#123; return cityDao.deleteCity(id); &#125;&#125; controller层代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758** * 城市 Controller 实现 Restful HTTP 服务 * * Created by ws on 10/12/2018. */@RestController@RequestMapping(value = "/api/city")public class CityRestController &#123; @Autowired private CityService cityService; /** * 根据id来查找 * @param id * @return */ @RequestMapping(value = "/&#123;id&#125;", method = RequestMethod.GET) public City findOneCity(@PathVariable("id") Long id) &#123; return cityService.findCityById(id); &#125; /** * 查询所有 * @return */ @RequestMapping(value = "/", method = RequestMethod.GET) public List&lt;City&gt; findAllCity() &#123; return cityService.findAllCity(); &#125; /** * 新增 * @param city */ @RequestMapping(value = "/", method = RequestMethod.POST) public void createCity(@RequestBody City city) &#123; cityService.saveCity(city); &#125; /** * 修改 * @param city */ @RequestMapping(value = "/", method = RequestMethod.PUT) public void modifyCity(@RequestBody City city) &#123; cityService.updateCity(city); &#125; /** * 删除 * @param id */ @RequestMapping(value = "/&#123;id&#125;", method = RequestMethod.DELETE) public void modifyCity(@PathVariable("id") Long id) &#123; cityService.deleteCity(id); &#125;&#125; 数据库配置文件 123456789## 数据源配置spring.datasource.url=jdbc:mysql://localhost:3306/springbootdb?useUnicode=true&amp;characterEncoding=utf8spring.datasource.username=rootspring.datasource.password=123456spring.datasource.driver-class-name=com.mysql.jdbc.Driver## Mybatis 配置mybatis.typeAliasesPackage=org.spring.springboot.domainmybatis.mapperLocations=classpath:mapper/*.xml 三，利用postman进行前端请求 根据 ID，获取城市信息 GET http://127.0.0.1:8080/api/city/1 获取城市列表 GET http://127.0.0.1:8080/api/city 新增城市信息 POST http://127.0.0.1:8080/api/city 更新城市信息 PUT http://127.0.0.1:8080/api/city 删除城市信息DELETE http://127.0.0.1:8080/api/city/2 四，更多信息springforall社区]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot快速入门之RESTful API以及单元测试]]></title>
    <url>%2F2018%2F12%2F19%2FspringBoot%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E4%B9%8BRESTful-API%E4%BB%A5%E5%8F%8A%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[首先我们来了解一下RESTful API 请求类型 URL 功能说明 GET /users 查询用户列表 POST /users 创建一个用户 PUT /users/id 根据id修改一个用户 DELETE /users/id 根据id删除一个用户 主要是用Spring MVC来实现一组对User对象操作的RESTful API，配合注释详细说明在Spring MVC中如何映射HTTP请求、如何传参、如何编写单元测试。 项目结构 User实体类12345678910111213141516171819202122232425262728293031public class UserPojo &#123; private String id; private String name; private String happay; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getHappay() &#123; return happay; &#125; public void setHappay(String happay) &#123; this.happay = happay; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; Conntroller层类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071@RestController/** 默认放回json数据格式，替换ReposeBody*/@RequestMapping(value = "/user")public class UserController &#123; //创建线程安全的map static Map&lt; String, UserPojo&gt; map = Collections.synchronizedMap( new HashMap&lt;String,UserPojo&gt;()); /** * 处理”/user的get请求，用来获取用户列表 * @return */ @RequestMapping(value = "/",method = RequestMethod.GET ) public List&lt;UserPojo&gt; getUser()&#123; List&lt;UserPojo&gt; listUser = new ArrayList&lt;UserPojo&gt;(map.values()); return listUser; &#125; /** * 处理”/user的post请求，新增用户 * @param userPojo * @return */ @RequestMapping(value = "/",method = RequestMethod.POST) public String postUser(@ModelAttribute UserPojo userPojo)&#123; // // 除了modelAttribute 绑定参数外还可以用@RequestParam从页面传递参数 map.put(userPojo.getId(),userPojo); return "success"; &#125; /** * 根据id来查询用户信息 * 处理"/users/&#123;id&#125;"的GET请求，用来获取url中id值的User信息 * @param id * @return */ @RequestMapping(value = "/&#123;id&#125;",method = RequestMethod.GET) public UserPojo getByUserId(@PathVariable String id)&#123; // url中的id可通过@PathVariable绑定到函数的参数中 return map.get(id); &#125; /** * 根据id来修改用户信息 * @param id * @param userPojo * @return */ @RequestMapping(value = "/&#123;id&#125;",method = RequestMethod.PUT) public String putByIdUser(@PathVariable String id,@ModelAttribute UserPojo userPojo)&#123; // 处理"/users/&#123;id&#125;"的PUT请求，用来更新User信息 UserPojo userPojo1 = new UserPojo(); userPojo1.setName(userPojo.getName()); userPojo1.setHappay(userPojo.getHappay()); map.put(id,userPojo1); return "success"; &#125; /** * 处理"/users/&#123;id&#125;"的DELETE请求，用来删除User * @param id * @return */ @RequestMapping(value = "/&#123;id&#125;",method = RequestMethod.DELETE) public String deleteByIdUser(@PathVariable String id)&#123; map.remove(id); return "success"; &#125;&#125; 测试结果下面针对该Controller编写测试用例验证正确性，具体如下。当然也可以通过浏览器插件等进行请求提交验证。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@RunWith(SpringRunner.class)@SpringBootTestpublic class UserControllerTests &#123; private MockMvc mockMvc; @Before public void setUp() throws Exception &#123; mockMvc = MockMvcBuilders.standaloneSetup(new UserController()).build(); &#125; @Test public void testUserController() throws Exception &#123; RequestBuilder requestBuilder = null; //get用户列表应该为空 requestBuilder = get("/user/"); mockMvc.perform(requestBuilder) .andExpect(status().isOk()) .andExpect(content().string(equalTo("[]"))); //新增一个用户期待应该是success requestBuilder = post("/user/") .param("id","1") .param("name","wusha") .param("happay","basketball"); mockMvc.perform(requestBuilder) .andExpect(content().string(equalTo("success"))); //get用户列表刚刚新增的数据 requestBuilder = get("/user/"); mockMvc.perform(requestBuilder) .andExpect(status().isOk()) .andExpect(content().string(equalTo("[&#123;\"id\":\"1\",\"name\":\"wusha\",\"happay\":\"basketball\"&#125;]"))); //根据id来查找用户信息 requestBuilder = get("/user/1"); mockMvc.perform(requestBuilder) .andExpect(content().string(equalTo("&#123;\"id\":\"1\",\"name\":\"wusha\",\"happay\":\"basketball\"&#125;"))); //根据id来修改用户信息 requestBuilder = put("/user/1") .param("name","shasha") .param("happay","football"); mockMvc.perform(requestBuilder) .andExpect(content().string(equalTo("success"))); //根据id来删除用户信息 requestBuilder = delete("/user/1"); mockMvc.perform(requestBuilder) .andExpect(content().string(equalTo("success"))); &#125;&#125; 注解最后再来复习一下springMVC的常用注解也就是我项目中用到的 @Controller：修饰class，用来创建处理http请求的对象 @RestController：Spring4之后加入的注解，原来在@Controller中返回json需要@ResponseBody来配合，如果直接用@RestController替代@Controller就不需要再配置@ResponseBody，默认返回json格式。 @RequestMapping：配置url映射 参数绑定的注解 @PathVariable是 映射 URL 绑定的占位符，通过 @PathVariable 可以将 URL 中占位符参数绑定到控制器处理方法的入参中：URL 中的 {xxx} 占位符可以通过@PathVariable(“xxx“) 绑定到操作方法的入参中。 @ModelAttribute，运用在参数上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用；运用在方法上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中； @RequestParam，主要用于将请求参数区域的数据映射到控制层方法的参数上]]></content>
  </entry>
  <entry>
    <title><![CDATA[String , StringBuffer , StringBuilder 之间的区别]]></title>
    <url>%2F2018%2F11%2F29%2FString-StringBuffer-StringBuilder-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[String , StringBuffer , StringBuilder 的区别String 是Java语言基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是典型的Imutable（不可变类） 被声明成为final class，所有属性也都是final。也由于他的不可变性，类似拼接，裁剪字符串等动作都会产生新的String 对象。 StringBuffer 是为解决上面提到的拼接产生太多中间对象的问题而提供的一个类，用append和add方法来添加字符串。StringBuffer本质上是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的情况，还是使用StringBuilder，实际上它的线程安全是通过把各种修改数据的方法都加上synchronized 关键字实现的 StringBulider是Java1.5中新增的，在能力上和StringBuffer没有本质区别，但是它去掉了吸纳从安全的部分，有效的减小了开销 StringBuffer 和 StringBuilder底层都是利用可修改的（char，JDK 9 以后是 byte）数组，二者都继承了 AbstractStringBuilder，里面包含了基本操作，区别仅在于最终的方法是否加了 synchronized 字符串设计和实现考量首先我们要知道String是Immutable（不可变类）的，字符串操作不会产生大量临时变量，以及线程安全的问题。由于String是Immutable的原生的保护了基础线程的安全，因为你无法对内部数据进行任何修改。 StringBuffer实现细节，他的线程安全都是通过各种修改数据都加上synchronized关键字实现的，非常直白。StringBuffer和StringBuild底层都是利用可修改的数组，二者都继承了AbstractStringBulider，区别在于是否加了synchronized关键字。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>StringBuffer</tag>
        <tag>StringBuild</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对比Vector,ArrayList,LinkedList有何区别]]></title>
    <url>%2F2018%2F11%2F29%2F%E6%AF%94Vector-ArrayList-LinkedList%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Vector,ArrayList,LinkedList相同点这三者都是实现集合框架中的List，也就是所谓的有序集合，因此具体功能也比较近似，比如都提供按照位置进行定位，添加或者删除的操作，都提供迭代器以遍历其内容。但因为具体的设计区别，在行为，性能，吸纳从安全等方面，表现又有很大的不同。 Vector,ArrayList,LinkedList区别ArrayList是应用更加广泛的动态数组实现，它本身不是线程安全的，所以新能要好很多。与Vector近似，ArrayList也是可以根据需要调整容量，不过两者的调整逻辑有所区别，Vecor在扩容时会提高一倍，而ArrayList则是增加50%。 LinkedList顾名思义是Java提供的双向链表，所以它不需要像上面两种那样调整容量，它也不是线程安全的。 常用情况Vector和ArrayList作为动态数组，其内部元素以数组形式顺序存储的，所以非常适合随机访问的场合。除了尾部插入和删除元素，往往性能会相对较差，比如我们在中间位置插入一个元素，需要移动后续所有元素。 而Linked List进行节点插入，删除却要高效很多，但是随机访问性能则要比动态数组慢。 底层实现图片描述的很清楚]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>vector</tag>
        <tag>arrayList</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashTabe，HashMap,TreeMap底层原理]]></title>
    <url>%2F2018%2F11%2F29%2FHashTabe%EF%BC%8CHashMap-TreeMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Map是广义java集合框架中的另外一部分，HaspMap作为框架中使用频率最高类型之一，我们有必要去深入了解它。 对比 HashMap,HashTable,TreeMap相同点 HashMap,HashTable,TreeMap都是一些常见的map实现，是以键值对的形式存储和操作数据的容器类型。 不同点 HashTable是早期的Java类库提供的的一个哈希表实现，本身是同步的，不支持null键和空值，由于同步导致的性能开销，使用相当较少。 HashMap是应用更加广泛的哈希表实现，行为上大致和haspTable大致相同，主要区别在于HashMap不是同步的，支持null键和空值。所以性能上更加优秀。 TreeMap是基于红黑树的一种提供顺序访问的Map,和HashMap不同，他的get，put,remove之类的操作都是O（log（n))的时间复杂度，具体顺序可以由指定的Comparator来决定，或者根据键的自然顺序来判断。 HashMap常见问题haspMap明确声明不是线程安全的的数据结构，所以haspMap在并发环境可能出现无限循环占用cpu，size不准确的诡异问题。 知识扩展map结构 hashMap等其他map实现都hi扩展abstractMap，里面包含了通用的抽象方法，HashMap的性能表现非常依赖于哈希码的有效性。 equals相等，hashcode一定要相等。 重写了hashCode也要重写equals。 hashCode需要保持一致性，状态改变的哈希值仍然要一致。 equals的对称，反射，传递。 LinkedHashMap 和 TreeMap 都可以保证某种顺序，但二者还是很不同的 linkedHashMap通常提供的是遍历顺序符合插入顺序，他的实现是通过条目维护一个双向链表。 对于TreeMap他的整体顺序是由键的顺序关系决定的，通过compartoar来决定。HashMap源码分析 HashMap 内部实现基本点分析。 容量（capacity）和负载系数（load factor）。 树化HashMap的内部结构，可以看作是数组和链表组成的复合结构，数组被分成一个个桶数组，通过哈希值在这个桶数组寻址，哈希值相同的键值对，则以链表形式存储。从非拷贝构造函数的实现来看，这个表格（数组）似乎并没有在最初就初始化好，仅仅设置了一些初始值而已。 12345public HashMap(int initialCapacity, float loadFactor)&#123; // ... this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);&#125; 然后看put方法实现 123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; put里面调用了putVal方法 1234567891011121314final V putVal(int hash, K key, V value, boolean onlyIfAbent, boolean evit) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int , i; if ((tab = table) == null || (n = tab.length) = 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == ull) tab[i] = newNode(hash, key, value, nll); else &#123; // ... if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for first treeifyBin(tab, hash); // ... &#125;&#125; 从源码种可以看出如果表格是null，resize会初始化它resize方法兼顾两个职责，创建初始存储表格，或者在容量不满足需求的时候进行扩容在放置新的键值对的时候，如果发生以下情况，就会发生扩容 12if (++size &gt; threshold) resize(); 具体键值在哈希表种的位置取决于下面的运算 1i = (n - 1) &amp; hash 最后hashMap为什么要树化，本质上是安全问题。因为在元素放置过程中，如果一个对象的哈希冲突，都被放置在一个桶中，会形成一个链表，链表查询是线性的会严重影响存取的性能。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>map</tag>
        <tag>hashMap</tag>
        <tag>HashTable</tag>
        <tag>TreeMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出的学习微服务之架构]]></title>
    <url>%2F2018%2F10%2F22%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[微服务架构到底是怎么样的？ 服务提供者按照一定的格式的服务描述，向注册中心注册服务，声明自己能够提供哪些服务，以及服务地址是什么，完成服务发布。 服务消费者请求注册中心，查询所需要调用的服务地址，然后以约定的通信协议向服务提供者发起请求，得到请求结果后再按照约定的协议解析结果 而且在服务调用过程中，服务的请求耗时，调用量，以及成功率等指标都会被记录下来用作监控，调用经过的链路信息会记录下来，用于故障定位和问题追踪。在这期间，如果调用失败，可以通过重试等服务治理手段来保证成功率。 微服务架构下 服务调用主要依赖于下面几个组件服务描述服务调用首先要解决的问题就是服务如何对外描述。比如，你对外提供了一个服务，那么这个服务的服务名是什么？调用这个服务需要提供哪些信息？调用这个服务返回的结果是什么格式的？该如何解析？这些就是服务描述要解决的问题。 常见的服务描述方式有RESTful API,XML 配置以及IDL文件三种。RESTful API方式通常用于HTTP协议的服务描述，并且常用Wiki或者Swagger来进行管理。下面是一个RESTful API方式的服务描述的例子。 XML配置方式多用作RPC协议的服务描述，通过*.xml配置文件来定义接口名，参数以及返回值类型等。下面是XML配置方式的服务描述 的例子。 IDL 文件方式通常用作 Thrift 和 gRPC 这类跨语言服务调用框架中，比如gRPC就是通过Protobuf文件来定义服务的接口名，参数以及返回值的数据结构，实例如下： 注册中心有了服务的接口描述，下一步要解决的问题就是服务的发布和订阅，就是说你提供一个服务，如何让外部想调用你的服务的人知道。这个时候就需要一个类似注册中心的角色，服务提供者将自己提供的服务以及地址登记到注册中心，服务消费者则从注册中心查询所需调用的服务的地址，然后发起请求。 注册中心的工作流程是： 服务提供者在启动时，根据服务发布文件中配置的发布信息向注册中心注册自己的服务。 服务消费者在启动时，根据消费者配置文件中配置的服务信息向注册中心订阅自己所需要的服务。 注册中心返回服务提供者地址列表给服务消费者。 当服务提供服务者发生变化，比如有节点新增或者销毁，注册中心将变更通知给服务消费者。 服务框架通过注册中心，服务消费者就可以获取到服务提供者的地址，有了地址就可以发起调用。但在发起调用之前你还需要解决以下几个问题。 服务通信采用什么协议？就是说服务提供者和服务消费者之间以什么样的协议进行网络通信，是采用四层TCP，UDP协议，还是采用七层HTTP协议，还是采用其他协议？ 数据传输采用什么方式？就是说服务提供者和服务消费者之间的数据传输采用哪种方式，是同步还是异步，实在单连接传输，还是多路复用。 数据压缩采用什么格式？通常数据传输都会对数据进行压缩，来减少网络传输的数据量，从而减少带宽消耗和网络传输时间，比如常见的JSON序列化，Java对象序列化以及Protobuf序列化等。 服务监控一旦服务消费者和服务提供者之间能够正常发起服务调用，你就需要对调用情况进行监控，以了解服务是否正常。通常来讲，服务监控主要包括三个流程。 指标收集。就是要吧每一次服务调用的请求耗时以及成功与否收集起来，并上传到集中的数据处理中心数据处理。有了每次调用的请求耗时以及成功与否等i西南西，就可以计算每秒服务请求量，平均耗时以及成功率等指标。 服务追踪除了需要对服务调用情况进行监控之外，你还需要记录服务调用经过的每一层链路，以便进行问题追踪和故障定位。服务追踪的工作原理大致如下： 服务消费者发起调用前，会在本地按照一定的规则生成一个requestid，发起调用时，将requestid当作请求参数的一部分，传递给服务提供者。 服务提供者接收到请求后，记录下这次请求的requestid，然后处理请求。如果服务提供者继续请求其他服务，会在本地再生成一个自己的requestid，然后把这两个requestid都当作请求参数传递下去。 以此类推，通过这种层层往下传递的方式，一次请求，无论最后依赖多少服务调用，经过多少服务节点，都可以通过最开始生成的requestid串联所有节点，从而达到服务追踪的目的。 服务治理服务监控能够发现问题，服务追踪能够定位问题所在，而解决问题就的靠服务治理。服务治理就是通过一系列的手段来保证在各种意外情况下，服务调用仍然能够正常进行。 单机故障。通常遇到单机故障，都是靠运维发现并重启服务或者从线上摘除故障节点。然而集群的规模越大，越是容易遇到单机故障，在机器规模超过一百台以上时，靠传统的人肉运维显然难以应对。而服务治理可以通过一定的策略，自动摘除故障节点，不需要认为干预，就能保证单机故障不会影响业务 单IDC故障。你应该经常听说某APP，因为施工挖断光缆导致大批量用户无法使用的严重故障。而服务治理可以通过自动化切换故障IDC的流量到其他正常IDC，可以避免因为单IDC故障引起的大批量业务受影响。 依赖服务不可用。比如你的服务依赖另一个服务，当另一个服务出现问题时，会拖慢甚至拖垮你的服务。而服务治理可以通过限流，在依赖服务异常的情况下，一段时间内停止发起调用而直接放回，这样一方面保证了服务消费者能够不被拖垮，另一方面也给服务提供者减少压力，使其能够尽快恢复。 总结这几个基本组件共同组成了微服务架构，在生产环境下缺一不可，所以在引入微服务架构之前，你的团队必须掌握这些基本组件的原理并具备相应的开发能力。]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[版本控制SoEasy之Git-04]]></title>
    <url>%2F2018%2F10%2F16%2F%E6%9C%AC%E6%8E%A7%E5%88%B6SoEasy%E4%B9%8BGit-04%2F</url>
    <content type="text"><![CDATA[讲了那么多，那么问题来了，在IEDA中如何使用Git？在这边我们先假定一些场景，然后根据这些场景来具体讲解在ieda中如何使用Git。工作中多人使用版本控制软件协作开发，常见的应用场景归纳如下： 假设小组中有两个人，组长盖茨，组员艾伦 场景一：盖茨创建项目并提交到远程Git仓库 场景二：艾伦从远程Git仓库上获取项目源码 场景三：艾伦修改了部分源码，提交到远程仓库 场景四：盖茨从远程仓库获取艾伦的提交 场景五：艾伦接受了一个新功能的任务，创建了一个分支并在分支上开发 场景六：艾伦把分支提交到远程Git仓库 场景七：盖茨获取艾伦提交的分支 场景八：盖茨把分支合并到主干 下面来看以上各场景在IDEA中对应的操作。 场景一：盖茨创建项目并提交到远程Git仓库在IDEA中配置Git如果是IDEA，直接使用快捷键，CTRL+alt+s，打开设置窗口。然后创建一个项目 选择VCS - &gt; Enable Version Control Integration，允许将项目集成到版本控制器中如果没有出现Enable Version Control Integration这个，说明你的项目已经集成了其他的版本控制，需要先删除其他的版本控制，加入git就可以了选择版本控制器类型完成后当前项目就变成一个Git项目，是工作空间 点击OK后创建完成本地仓库，注意，这里仅仅是本地的。下面把项目源码添加到本地仓库。 下图是Git与提交有关的三个命令对应的操作，Add命令是把文件从IDE的工作目录添加到本地仓库的stage区，Commit命令把stage区的暂存文件提交到当前分支的仓库，并清空stage区。Push命令把本地仓库的提交同步到远程仓库。 IDEA中对操作做了一定的简化，Commit和Push可以在一步中完成。 具体操作，在项目上点击右键，选择Git菜单，如果使用Add则将文件从工作空间提交到暂存库，Commit Directory则是同时完成提交到暂存与本地仓库。 选择要提交的文件，填写消息将本地仓库的内容提交到远程仓库 定义远程地址的别名，以及地址url，然后就出现下图 提示Push Successful就成功了 场景二：艾伦从远程Git仓库上获取项目源码即克隆项目，操作如下输入盖茨Push时填写的远程仓库地址填写仓库地址、要克隆到的父目录与项目目录 接下来按向导操作，即可把项目从远程仓艾伦隆到本地仓库和IDE工作区。 当提示签出成功点击打开就可以看到项目了 场景三：艾伦修改了部分源码，提交到远程仓库这个操作和首次提交的流程基本一致，分别是 Add -&gt; Commit -&gt; Push。请参考场景一 添加一个类，并提交提交到本地仓库提交到远程仓库 场景四：盖茨从远程仓库获取艾伦的提交获取更新有两个命令：Fetch和Pull，Fetch是从远程仓库下载文件到本地的origin/master，然后可以手动对比修改决定是否合并到本地的master库。Pull则是直接下载并合并。如果各成员在工作中都执行修改前先更新的规范，则可以直接使用Pull方式以简化操作。选择分支 场景五：艾伦接受了一个新功能的任务，创建了一个分支并在分支上开发建分支也是一个常用的操作，例如临时修改bug、开发不确定是否加入的功能等，都可以创建一个分支，再等待合适的时机合并到主干。 创建流程如下：选择New Branch并输入一个分支的名称创建完成后注意IDEA的右下角，如下图，Git: dev表示已经自动切换到dev分支，当前工作在这个分支上。 点击后弹出一个小窗口，在Local Branches中有其他可用的本地分支选项，点击后选择Checkout即可切换当前工作的分支(见场景7操作切换其他分支)。 如下图，点击Checkout,切换到分支 注意，这里创建的分支仅仅在本地仓库，如果想让组长盖茨获取到这个分支，还需要提交到远程仓库。 场景六：艾伦把分支提交到远程Git仓库切换到新建的分支，使用Push功能提交到远程 艾伦将新开发的功能提交到远程提交到远程 场景七：盖茨获取艾伦提交的分支使用Pull功能打开更新窗口，点击Remote栏后面的刷新按钮，会在Branches to merge栏中刷新出新的分支。这里并不想做合并，所以不要选中任何分支，直接点击Pull按钮完成操作。 更新后，再点击右下角，可以看到在Remote Branches区已经有了新的分支，点击后在弹出的子菜单中选择Checkout as new local branch，在本地仓库中创建该分支。完成后在Local Branches区也会出现该分支的选项，可以按上面的方法，点击后选择Checkout切换。 切换远程分支：(dev1是我自己创建的分支，点击可以切换分支） 场景八：盖茨把分支合并到主干新功能开发完成，体验很好，项目组决定把该功能合并到主干上。 切换到master分支，选择Merge Changes选择要合并的分支，点击Merge完成 以上就是Git在项目中的基本应用，关于基本应用如有遇到问题，欢迎留言。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>GitGui</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[版本控制SoEasy之Git-03]]></title>
    <url>%2F2018%2F10%2F16%2F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6SoEasy%E4%B9%8BGit-03%2F</url>
    <content type="text"><![CDATA[之前理解了Git分支，现在我们来学习远程仓库操作。 远程仓库常用命令1234567891011121314151617181920212223242526272829303132333435363738394041424344# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all#简单查看远程---所有仓库git remote （只能查看远程仓库的名字）#查看单个仓库git remote show [remote-branch-name]#新建远程仓库git remote add [branchname] [url]#修改远程仓库git remote rename [oldname] [newname]#删除远程仓库git remote rm [remote-name]#获取远程仓库数据git fetch [remote-name] (获取仓库所有更新，但不自动合并当前分支)git pull (获取仓库所有更新，并自动合并到当前分支)#上传数据，如git push origin mastergit push [remote-name] [branch] git clone 克隆远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到git clone命令。 1$ git clone &lt;版本库的网址&gt; git remote为了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。 不带选项的时候，git remote命令列出所有远程主机。 1$ git remote 使用-v选项，可以参看远程主机的网址。 1$ git remote -v git remote add命令用于添加远程主机。 1$ git remote add &lt;主机名&gt; &lt;网址&gt; git remote rm命令用于删除远程主机。 1$ git remote rm &lt;主机名&gt; git remote rename命令用于远程主机的改名。 1$ git remote rename &lt;原主机名&gt; &lt;新主机名&gt; git fetch（同步）一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到git fetch命令 1$ git fetch &lt;远程主机名&gt; 上面命令将某个远程主机的更新，全部取回本地。 git fetch命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。 默认情况下，git fetch取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。 1$ git fetch &lt;远程主机名&gt; &lt;分支名&gt; 比如，取回origin主机的master分支。 1$ git fetch origin master 所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。 git branchgit branch命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。 123456$ git branch -rorigin/master$ git branch -a* master remotes/origin/master 上面命令表示，本地主机的当前分支是master，远程分支是origin/master。 取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建一个新的分支。 1$ git checkout -b newBrach origin/master 上面命令表示，在origin/master的基础上，创建一个新分支。 此外，也可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支。 $ git merge origin/master #或者 $ git rebase origin/master 上面命令表示在当前分支上，合并origin/master。 git pullgit pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。 $ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。 $ git pull origin next:master 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。 $ git pull origin next 上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。 $ git fetch origin $ git merge origin/next 在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支。 Git也允许手动建立追踪关系。 git branch --set-upstream master origin/next 上面命令指定master分支追踪origin/next分支。 如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。 $ git pull origin 上面命令表示，本地的当前分支自动与对应的origin主机”追踪分支”（remote-tracking branch）进行合并。 如果当前分支只有一个追踪分支，连远程主机名都可以省略。 $ git pull 上面命令表示，当前分支自动与唯一一个追踪分支进行合并。 如果合并需要采用rebase模式，可以使用–rebase选项。 $ git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。 但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。 $ git pull -p #同于下面的命令 $ git fetch --prune origin $ git fetch -p git pushgit push命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相仿。 $ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以git pull是&lt;远程分支&gt;:&lt;本地分支&gt;，而gitpush是&lt;本地分支&gt;:&lt;远程分支&gt;。 如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。 $ git push origin master 上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。 $ git push origin :master #等同于 $ git push origin --delete master 上面命令表示删除origin主机的master分支。 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。 $ git push origin 上面命令表示，将当前分支推送到origin主机的对应分支。如果是新建分支第一次push，会提示： fatal: The current branch dev1 has no upstream branch. To push the current branch and set the remote as upstream, use git push --set-upstream origin dev1 输入这行命令，然后输入用户名和密码，就push成功了。 以后的push就只需要输入git push origin 原因是： 12345678910111213141516#因为在git的全局配置中，有一个push.default属性，其决定了git push操作的默认行为。在Git 2.0之前，这个属性的默认被设为'matching'，2.0之后则被更改为了'simple'。#我们可以通过git version确定当前的git版本（如果小于2.0，更新是个更好的选择），通过git config --global push.default 'option'改变push.default的默认行为（或者也可直接编辑~/.gitconfig文件）。push.default 有以下几个可选值：nothing, current, upstream, simple, matching其用途分别为：nothing - push操作无效，除非显式指定远程分支，例如git push origin develop（我觉得。。。可以给那些不愿学git的同事配上此项）。current - push当前分支到远程同名分支，如果远程同名分支不存在则自动创建同名分支。upstream - push当前分支到它的upstream分支上（这一项其实用于经常从本地分支push/pull到同一远程仓库的情景，这种模式叫做central workflow）。simple - simple和upstream是相似的，只有一点不同，simple必须保证本地分支和它的远程upstream分支同名，否则会拒绝push操作。matching - push所有本地和远程两端都存在的同名分支。因此如果我们使用了git2.0之前的版本，push.default = matching，git push后则会推送当前分支代码到远程分支，而2.0之后，push.default = simple，如果没有指定当前分支的upstream分支，就会收到上文的fatal提示。 如果当前分支只有一个追踪分支，那么主机名都可以省略。 $ git push 如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。 $ git push -u origin master 上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。 不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。 $ git config --global push.default matching #或者 $ git config --global push.default simple 还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用–all选项。 $ git push --all origin 上面命令表示，将所有本地分支都推送到origin主机。 如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用–force选项。 $ git push --force origin 上面命令使用–force选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用–force选项。 最后，git push不会推送标签（tag），除非使用–tags选项。 $ git push origin --tags]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>版本控制</tag>
        <tag>git常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[版本控制SoEasy之Git-02]]></title>
    <url>%2F2018%2F10%2F16%2F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6SoEasy%E4%B9%8BGit-02%2F</url>
    <content type="text"><![CDATA[Git的原理和基本操作，在我的上一篇博客里面已经有详细的说明了。这一篇我们来介绍git分支。 分支对大部分开发人员来说并不陌生，Git的分支也不例外。 分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。 现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 Git分支的速度非常快。 截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。直接看图清晰明了 git分支中常用指令123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 新建分支与分支切换每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长：默认是这样的，master是主分支新建一个分支，但依然停留在当前分支，使用：$ git branch [branch-name]当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： 所以Git合并分支也很快！就改改指针，工作区内容也不变！ 合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支： 切换分支，git branch ，如果name为-则为上一个分支 新建一个分支，并切换到该分支，$ git checkout -b [branch] 新建一个分支，指向指定commit使用命令：$ git branch [branch] [commit] 新建一个分支，与指定的远程分支建立追踪关系使用命令：$ git branch –track [branch][remote-branch] 查看分支 列出所有本地分支使用$ git branch 列表所有远程分支使用$ git branch -r 列出所有本地分支和远程分支使用$ git branch -a分支合并合并指定分支到当前分支使用指令$ git merge [branch]解决冲突如果同一个文件在合并分支时都被修改了则会引起冲突分支策略 master主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。 删除分支删除本地分支可以使用命令：$ git branch -d [branch-name]，-D（大写）强制删除删除远程分支可以使用如下指令： $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] -d表示删除分支。分支必须完全合并在其上游分支，或者在HEAD上没有设置上游 -r表示远程的意思remotes，如果-dr则表示删除远程分支 下一篇我们开始讲，git集成IEDA和GitHub的操作]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>版本控制</tag>
        <tag>git分支</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[版本控制SoEasy之Git-01]]></title>
    <url>%2F2018%2F10%2F10%2F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6SoEasy%E4%B9%8BGit-01%2F</url>
    <content type="text"><![CDATA[Git是什么？Git是一种常用的版本控制系统，我们常见的版本控制系统有git和svn。 要知道怎么使用首先要了解它的概念。 什么是版本控制版本控制是指对软件开发过程中各种程序代码、配置文件及说明文档等文件变更的管理，是软件配置管理的核心思想之一。 实现跨区域多人协同开发 追踪和记载一个或者多个文件的历史记录 组织和保护你的源代码和文档 统计工作量 并行开发、提高开发效率 跟踪记录整个软件的开发过程 减轻开发人员的负担，节省时间，同时降低人为错误Git常用术语 记住git的常用术语对后续理解git的基本操作有着至关重要的作用 仓库（Repository）受版本控制的所有文件修订历史的共享数据库 工作空间（WorkSpace）本地硬盘或Unix 用户帐户上编辑的文件副本 工作树/区（Working tree)工作区包含了仓库的工作文件。您可以修改和提交更改然后提交到仓库。 暂存区（Staging area)暂存区是工作区提交之后的地方。 索引（index）索引是暂存区的另一种术语 签入（Checkin)将新版本签入回仓库 签出（checkout） 从仓库中将文件的最新修订版本复制到工作空间 提交（Commit)对各自文件的工作副本做了更改，并将这些更改提交到仓库 冲突（Conflict)多人对同一文件的工作副本进行更改，并将这些更改提交到仓库 合并（Merge)将某分支上的更改联接到此主干或同为主干的另一个分支 分支（Branch)从主线上分离开的副本，默认分支叫master 锁（Lock）获得修改文件的专有权限。 头（HEAD)头是一个象征性的参考，最常用以指向当前选择的分支。 修订（Revision)表示代码的一个版本状态。Git通过用SHA1 hash算法表示的ID来标识不同的版本。 标记（Tags）标记指的是某个分支某个特定时间点的状态。通过标记，可以很方便的切换到标记时的状态。 Git和SVNSVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 GitBash常用命令 cd ~ 回home cd ..回退到上一个目录，直接cd进入默认目录 pwd：显示当前所在目录路径 ls(ll): 都是列出当前目录中的所有文件，只不过ll列出的内容更为详细 touch： 新建一个文件 rm :删除一个文件 mkdir：新建一个文件 rm -r ：删除一个文件夹，rm -r src删除src目录 mv ：移动文件，mv index. reset： 清屏 history： 查看命令历史 help 帮助 exit 推出 #表示注释 显示文件内容 cat Git常用命令查看配置,可以查看现在git环境配置 git config -l 查看系统 config git config --system --list 查看当前用户global的配置 git config --global --list 查看当前仓库配置 git config --local --list 设置用户名和邮箱 12$ git config --global user.name "guogugo" #名称$ git config --global user.email gguo@qq.com #邮箱 总之–global为全局配置，不加则为某个项目的特定配置。 添加配置项 git config [--local|--global|--system] section.key value [--local|--global|--system] #可选的，对应本地，全局，系统不同级别的设置 section.key #区域下的键 value #对应的值 删除配置项 1git config [--local|--global|--system] --unset section.key git 理论基础工作区域Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下： Workspace：工作区，就是你平时存放项目代码的地方 Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息 Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本 Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换下面这张图能更好的说明 Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。 WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。 .git：存放Git管理信息的目录，初始化仓库的时候自动创建。Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。 Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。 Stash：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。git 的工作流程 Git基本git的工作流程一般是这样的： 在工作目录中添加、修改文件； 将需要进行版本管理的文件放入暂存区域； 将暂存区域的文件提交到git仓库。（这里是本地仓库） 因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)操作图解教程直接看图理解本地git的提交过程 Git的基本操作创建工作目录与常用指令工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。 日常使用只要记住下图6个命令： 获得git仓库需要用GIT管理的项目的根目录执行（注意自己当前目录的位置): 12# 在当前目录新建一个Git代码库$ git init 执行后项目目录会多出一个.git文件夹，关于版本等信息都在这里面，如果没有看到可以百度怎么查看隐藏文件 使用如下命令，可以把创建目录与仓库一起完成 12# 新建一个目录，将其初始化为Git代码库$ git init [project-name] 克隆远程仓库另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地，而不是取某一个特定版本，所以用clone而不是checkout，语法格式如下： 12# 克隆一个项目和它的整个代码历史(版本信息)$ git clone [url] 注意url为https……的地址 git 文件操作版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。GIT不关心文件两个版本之间的具体差别，而是关心文件的整体是否有改变，若文件被改变，在添加提交时就生成文件新版本的快照，而判断文件整体是否改变的方法就是用SHA-1算法计算文件的校验和。 文件四种状态 Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged. Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改,而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件 Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过gitadd可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个gitcheckout即从库中取出文件, 覆盖当前修改 Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致,文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified查看文件状态 12345#查看指定文件状态git status [filename]#查看所有文件状态git status 添加文件和目录 工作区（Working Directory）就是你在电脑里能看到的目录。 版本库（Repository）工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 将untracked状态的文件添加到暂存区，语法格式如下： 12345678# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add . 移除文件与目录 12#直接从暂存区删除文件，工作区则不做出改变git rm --cached &lt;file&gt; 12#如果已经用add 命令把文件加入stage了，就先需要从stage中撤销git reset HEAD &lt;file&gt;... 当执行 “git reset HEAD” 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。 123#移除所有未跟踪文件#一般会加上参数-df，-d表示包含目录，-f表示强制清除。git clean [options] 12345678#只从stage中删除，保留物理文件git rm --cached readme.txt #不但从stage中删除，同时删除物理文件git rm readme.txt #把a.txt改名为b.txtgit mv a.txt b.txt 当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master指向的目录树就是提交时暂存区的目录树。 当执行 “git reset HEAD” 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。 当执行 “git rm –cached ” 命令时，会直接从暂存区删除文件，工作区则不做出改变。 当执行 “git checkout .” 或者 “git checkout — ”命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。 当执行 “git checkout HEAD .” 或者 “git checkout HEAD ” 命令时，会用 HEAD指向的 master分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。查看文件修改后的差异git diff用于显示WorkSpace中的文件和暂存区文件的差异 12#查看文件修改后的差异git diff [files] -a表示修改之前的文件，+++b表示修改后的文件 12#比较暂存区的文件与之前已经提交过的文件git diff --cached 也可以把WorkSpace中的状态和repo中的状态进行diff，命令如下: 12#比较repo与工作空间中的文件差异git diff HEAD~n 签出如果仓库中已经存在文件f4.txt，在工作区中对f4修改了，如果想撤销可以使用checkout，签出覆盖 检出命令git checkout是git最常用的命令之一，同时也是一个很危险的命令，因为这条命令会重写工作区 语法： 123456#用法一git checkout [-q] [&lt;commit&gt;] [--] &lt;paths&gt;...#用法二git checkout [&lt;branch&gt;]#用法三git checkout [-m] [[-b]--orphan] &lt;new_branch&gt;] [&lt;start_point&gt;] 1234567891011121314151617181920$ git checkout branch#检出branch分支。要完成图中的三个步骤，更新HEAD以指向branch分支，以及用branch 指向的树更新暂存区和工作区。$ git checkout#汇总显示工作区、暂存区与HEAD的差异。$ git checkout HEAD#同上$ git checkout -- filename#用暂存区中filename文件来覆盖工作区中的filename文件。相当于取消自上次执行git add filename以来（如果执行过）的本地修改。$ git checkout branch -- filename#维持HEAD的指向不变。用branch所指向的提交中filename替换暂存区和工作区中相 应的文件。注意会将暂存区和工作区中的filename文件直接覆盖。$ git checkout -- . 或写作 git checkout .#注意git checkout 命令后的参数为一个点（“.”）。这条命令最危险！会取消所有本地的 #修改（相对于暂存区）。相当于用暂存区的所有文件直接覆盖本地文件，不给用户任何确认的机会！$ git checkout commit_id -- file_name#如果不加commit_id，那么git checkout -- file_name 表示恢复文件到本地版本库中最新的状态。 提交通过add只是将文件或目录添加到了index暂存区，使用commit可以实现将暂存区的文件提交到本地仓库。 123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区，跳过了add,对新文件无效$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 修订提交如果我们提交过后发现有个文件改错了，或者只是想修改提交说明，这时可以对相应文件做出修改，将修改过的文件通过”git add”添加到暂存区，然后执行以下命令： 12# 修订提交git commit --amend 撤销提交（commit）原理就是放弃工作区和index的改动，同时HEAD指针指向前一个commit对象 12#撤销上一次的提交git reset --hard HEAD~1 查看日志与历史 查看提交日志可以使用git log指令，语法格式如下： 12#查看提交日志git log [&lt;options&gt;] [&lt;revision range&gt;] [[\--] &lt;path&gt;…?] 撤销暂存区跟新使用”git add”把更新提交到了暂存区。这时”git status”的输出中提示我们可以通过”git reset HEAD …”把暂存区的更新移出到WorkSpace中 撤销本地库更新在Git中，有一个HEAD指针指向当前分支中最新的提交。当前版本，我们使用”HEAD^”，那么再钱一个版本可以使用”HEAD^^”，如果想回退到更早的提交，可以使用”HEAD~n”。（也就是，HEAD^=HEAD~1，HEAD^^=HEAD~2） 优质参考张果教你用git]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>版本控制</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL基础]]></title>
    <url>%2F2018%2F09%2F29%2FSQL%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[mysql dos常用命令打开mysql服务 net start mysql 关闭mysql服务 net stop mysql 登陆mysql mysql -u root -p 连接到远程主机上的mysql假设远程主机ip为： 22.22.22.22 ,用户名为root ，密码为abcd123.则键入以下命令 mysql -h22.22.22.22 -u root -p abc123 退出mysql exit 修改密码修改root 密码 update user set password=password(&quot;sss&quot;) where user = &quot;root&quot;; 打开数据库 use datatable 显示所有数据库 show databases; 显示数据库mysql里的所有表，先切入到数据库（如use datatables)，才能看到表 show tables; 显示表mysql数据库中的user表的列信息 describe user; 数据库创建 create database db_name; 删除数据库 drop database db_name;删除时可先判断是否存在，drop database if exits db_name 建表 create table table_name(字段一 数据类型，字段二 数据类型）； 添加数据 insert into 表名[(字段一，字段二）]value (值1，值2）；如果向表中的每一个字段都插入一个值，[]中括号里面的可以不用写 查询表里所有数据 select * from tbale; 更新指定数据 update table_name set 字段名 = &apos;新值‘where id =1; 删除表中数据 delete from table_name; 一次创建多个数据库用户 create user username identified by &apos;password&apos; ,username2 identified by &apos;password&apos; 用户的权限控制将某个库中的某个表的控制权赋予某个用户 grant all on db_name.table_name to user_name [indentified by &apos;password&apos;]; 表结构的修改增加一个字段 alert table table_name add column 字段名 字段类型 alter 某字段； 修改字段名称 alter table table_name change 旧字段名 新字段名 新字段类型； 改表的名字 alter table table_name rename to new_table_name; 一次性清空表中的所有数据 truncate table table_name; 备份数据库 mysqldump -h host -u root -p dbname &gt;dbname_backup.sql sql常用函数 “Websites” 表+—-+————–+—————————+——-+———+| id | name | url | alexa | country |+—-+————–+—————————+——-+———+| 1 | Google | https://www.google.cm/ | 1 | USA || 2 | 淘宝 | https://www.taobao.com/ | 13 | CN || 3 | 菜鸟教程 | http://www.runoob.com/ | 4689 | CN || 4 | 微博 | http://weibo.com/ | 20 | CN || 5 | Facebook | https://www.facebook.com/ | 3 | USA || 7 | stackoverflow | http://stackoverflow.com/ | 0 | IND |+—-+—————+—————————+——-+———+ “access_log”表+—–+———+——-+————+| aid | site_id | count | date |+—–+———+——-+————+| 1 | 1 | 45 | 2016-05-10 || 2 | 3 | 100 | 2016-05-13 || 3 | 1 | 230 | 2016-05-14 || 4 | 2 | 10 | 2016-05-14 || 5 | 5 | 205 | 2016-05-14 || 6 | 4 | 13 | 2016-05-15 || 7 | 3 | 220 | 2016-05-15 || 8 | 5 | 545 | 2016-05-16 || 9 | 3 | 201 | 2016-05-17 |+—–+———+——-+————+ 有用的 Aggregate 函数： AVG() - 返回平均值 COUNT() - 返回行数 FIRST() - 返回第一个记录的值 LAST() - 返回最后一个记录的值 MAX() - 返回最大值 MIN() - 返回最小值 SUM() - 返回总和 AVG() - 返回平均值下面的 SQL 语句选择访问量高于平均访问量的 “site_id” 和 “count”： SELECT site_id, count FROM access_log WHERE count &gt; (SELECT AVG(count) FROM access_log); COUNT() - 返回行数 COUNT() 函数返回匹配指定条件的行数。适用于mysql，和OracleCOUNT(DISTINCT column_name) 函数返回指定列的不同值的数目： SELECT COUNT(DISTINCT column_name) FROM table_name; MAX 下面的 SQL 语句从 “Websites” 表的 “alexa” 列获取最大值： SELECT MAX(alexa) AS max_alexa FROM Websites; MIN 下面的 SQL 语句从 “Websites” 表的 “alexa” 列获取最小值： SELECT MIN(alexa) AS min_alexa FROM Websites; SUM 下面的 SQL 语句查找 “access_log” 表的 “count” 字段的总数： SELECT SUM(count) AS nums FROM access_log; GROUP BY GROUP BY 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。 下面的 SQL 语句统计所有网站的访问的记录数： SELECT Websites.name,COUNT(access_log.aid) AS nums FROM access_log LEFT JOIN Websites ON access_log.site_id=Websites.id GROUP BY Websites.name; HAVING 子句在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与聚合函数一起使用。HAVING 子句可以让我们筛选分组后的各组数据。下面的 SQL 语句统计所有网站的访问的记录数： SELECT Websites.name,COUNT(access_log.aid) AS nums FROM access_log LEFT JOIN Websites ON access_log.site_id=Websites.id GROUP BY Websites.name; 现在我们想要查找总访问量大于 200 的网站，并且 alexa 排名小于 200。我们在 SQL 语句中增加一个普通的 WHERE 子句： SELECT Websites.name, SUM(access_log.count) AS nums FROM Websites INNER JOIN access_log ON Websites.id=access_log.site_id WHERE Websites.alexa &lt; 200 GROUP BY Websites.name HAVING SUM(access_log.count) &gt; 200; UCASE() 函数UCASE() 函数把字段的值转换为大写。 下面的 SQL 语句从 “Websites” 表中选取 “name” 和 “url” 列，并把 “name” 列的值转换为大写： SELECT UCASE(name) AS site_title, url FROM Websites; LCASE() 函数LCASE() 函数把字段的值转换为小写。 下面的 SQL 语句从 “Websites” 表中选取 “name” 和 “url” 列，并把 “name” 列的值转换为小写： SELECT LCASE(name) AS site_title, url FROM Websites; MID() 函数MID() 函数用于从文本字段中提取字符。 SELECT MID(column_name,start[,length]) FROM table_name;下面的 SQL 语句从 “Websites” 表的 “name” 列中提取前 4 个字符： SELECT MID(name,1,4) AS ShortTitle FROM Websites; LEN() 函数LEN() 函数返回文本字段中值的长度。 SELECT name, LENGTH(url) as LengthOfURL FROM Websites; ROUND() 函数ROUND() 函数用于把数值字段舍入为指定的小数位数。SELECT ROUND(column_name,decimals) FROM table_name;decimals 必需。规定要返回的小数位数。 ROUND(X,D)： 返回参数X的四舍五入的有 D 位小数的一个数字。如果D为0，结果将没有小数点或小数部分。 mysql&gt; select ROUND(1.298, 1); -&gt; 1.3 mysql&gt; select ROUND(1.298, 0); -&gt; 1 FORMAT() 函数 FORMAT() 函数用于对字段的显示进行格式化。SELECT FORMAT(column_name,format) FROM table_name; column_name 必需,要格式化的字段。format 必需,规定格式。 下面的 SQL 语句从 “Websites” 表中选取 name, url 以及格式化为 YYYY-MM-DD 的日期： SELECT name, url, DATE_FORMAT(Now(),&apos;%Y-%m-%d&apos;) AS date FROM Websites; 参考快速查看]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM项目的相关配置]]></title>
    <url>%2F2018%2F09%2F25%2FSSM%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[SSM项目的相关配置众所周知，SSM项目的配置主要有六个(当然还有一些其他配置），web.xml的配置，Spring的配置（applicationContext.xml），SpringMVC配置（servlet-mvc.xml），Mybaits的配置（mybatis-config.xml ），JDBC文件与Log4j配置文件。 下面我们就来仔细讲解这六个配置web.xml的配置配置web.xml主要有两个内容，一个是Spring，一个是SpringMVC的配置。 Spring配置信息 通过全局上下文参数来加载Spring配置文件 配置监听器 在web.xml中继续配置Spring MVC 首先配置servlet 通过Servlet标签配置dispatchServlet.需要初始化参数，加载spring MVC配置文件。 配置Mapping 下面是我的web.xml配置文件的例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 &lt;!--Spring的配置信息 通过全局上下文参数来加载Sprin配置文件--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:applicationContext*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;session-config&gt; &lt;session-timeout&gt;120&lt;/session-timeout&gt; &lt;/session-config&gt; &lt;!--配置监听器，通过监听器的方式来Spring框架运行起来--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--解决中文乱码--&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;!--配置编码格式--&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--默认首页--&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;due/index&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!--Spring MVC的配置信息 通过Servlet标签配置dispatcher--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--需要一个初始化参数，加载spring MVC配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:springmvc-context.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--容器启动加载servlet--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--/监听全局路径--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/due/index&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; Spring的配置 自动扫描：根据注解创建实例化，控制反转。 引入配置文件。jdbc的驱动包等信息。 配置数据源。需要的信息根据第二步中的jdbc中的配置文件来引用。 配置Mybaits的SqlSessionFactory:有了它可以MyBaits（1：数据源：第三步配置数据源。2：自动扫描mappers.xml文件。所有的映射文件。放在一个对应的路径下。3：加载Mybaits的配置文件 DAO层接口包。该包下的所有都会被实例化。-配置事务管理：交由Spring来管理（定义事物传播属性） 配置事物切面。 异常处理相关。 下面是applicationContext.xml配置信息1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xmlns:jee="http://www.springframework.org/schema/jee" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation=" http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 自动扫描 --&gt; &lt;context:component-scan base-package="com.sys.dao" /&gt; &lt;context:component-scan base-package="com.sys.service" /&gt; &lt;context:component-scan base-package="com.sys.entity"/&gt; &lt;!-- 引入配置文件，可以使用$&#123;&#125;语法，location:指定读取文件的路径 --&gt; &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" p:driverClass="$&#123;jdbc.driverClassName&#125;" p:jdbcUrl="$&#123;jdbc.url&#125;" p:user="$&#123;jdbc.username&#125;" p:password="$&#123;jdbc.password&#125;" p:initialPoolSize="$&#123;jdbc.initialSize&#125;" p:maxPoolSize="$&#123;jdbc.maxActive&#125;"/&gt; &lt;!-- 配置mybatis的sqlSessionFactory --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 自动扫描mappers.xml文件 --&gt; &lt;property name="mapperLocations" value="classpath:mybatis/mappers/*.xml"&gt;&lt;/property&gt; &lt;!-- mybatis配置文件 --&gt; &lt;property name="configLocation" value="classpath:mybatis/mybatis-config.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.sys.dao" /&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 配置事务通知属性 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;!-- 定义事务传播属性 --&gt; &lt;!-- PROPAGATION_REQUIRED--支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。 PROPAGATION_SUPPORTS--支持当前事务，如果当前没有事务，就以非事务方式执行。--&gt; &lt;tx:attributes&gt; &lt;tx:method name="add*" propagation="REQUIRED" /&gt; &lt;tx:method name="append*" propagation="REQUIRED" /&gt; &lt;tx:method name="insert*" propagation="REQUIRED" /&gt; &lt;tx:method name="save*" propagation="REQUIRED" /&gt; &lt;tx:method name="update*" propagation="REQUIRED" /&gt; &lt;tx:method name="modify*" propagation="REQUIRED" /&gt; &lt;tx:method name="edit*" propagation="REQUIRED" /&gt; &lt;tx:method name="delete*" propagation="REQUIRED" /&gt; &lt;tx:method name="remove*" propagation="REQUIRED" /&gt; &lt;tx:method name="repair" propagation="REQUIRED" /&gt; &lt;tx:method name="delAndRepair" propagation="REQUIRED" /&gt; &lt;tx:method name="get*" propagation="SUPPORTS" /&gt; &lt;tx:method name="find*" propagation="SUPPORTS" /&gt; &lt;tx:method name="load*" propagation="SUPPORTS" /&gt; &lt;tx:method name="search*" propagation="SUPPORTS" /&gt; &lt;tx:method name="datagrid*" propagation="SUPPORTS" /&gt; &lt;tx:method name="*" propagation="SUPPORTS" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置事务切面 --&gt; &lt;aop:config&gt; &lt;aop:pointcut id="serviceOperation" expression="execution(* com.sys.service.*.*(..))" /&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="serviceOperation" /&gt; &lt;/aop:config&gt; &lt;!-- 异常统一处理 --&gt; &lt;!-- &lt;bean id="exceptionResolver" class="com.sys.util.HandlerException"/&gt; --&gt;&lt;/beans&gt; 需要注意的地方（1） advice（建议）的命名：由于每个模块都会有自己的Advice，所以在命名上需要作出规范，初步的构想就是模块名+Advice（只是一种命名规范）。 （2） tx:attribute标签所配置的是作为事务的方法的命名类型。 如&lt;tx:method name=”save*” propagation=”REQUIRED”/&gt; 其中*为通配符，即代表以save为开头的所有方法，即表示符合此命名规则的方法作为一个事务。 propagation=”REQUIRED”代表支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。 （3） aop:pointcut标签配置参与事务的类，由于是在Service中进行数据库业务操作，配的应该是包含那些作为事务的方法的Service类。 首先应该特别注意的是id的命名，同样由于每个模块都有自己事务切面，所以我觉得初步的命名规则因为 all+模块名+ServiceMethod。而且每个模块之间不同之处还在于以下一句： 1expression="execution(*com.test.testAda.test.model.service.*.*(..))" 其中第一个代表返回值，第二代表service下子包，第三个*代表方法名，“（..）”代表方法参数。 （4） aop:advisor标签就是把上面我们所配置的事务管理两部分属性整合起来作为整个事务管理。 图解： Spring MVC(Servlet-mvc.xml)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xmlns:jee="http://www.springframework.org/schema/jee" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation=" http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 使用注解的包，包括子集 --&gt; &lt;context:component-scan base-package="com.sys.controller" /&gt; &lt;!-- 添加数据转换的注解驱动 --&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;bean class="org.springframework.http.converter.StringHttpMessageConverter"/&gt; &lt;bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"/&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;!-- 视图解析器 --&gt; &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/" /&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 上传组件 --&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!-- 设置上传的编码格式 --&gt; &lt;property name="defaultEncoding" value="utf-8"/&gt; &lt;!-- 设置最大上传大小 --&gt; &lt;property name="maxUploadSize" value="5242880"/&gt; &lt;/bean&gt; &lt;!-- 静态资源配置设置：除了控制器一概不管理 --&gt; &lt;mvc:default-servlet-handler/&gt;&lt;/beans&gt; JDBC和Log4配置文件。（日志文件，将错误信息保存在日志文件，前台不能显示错误文件，也可以保存用户访问信息，以及数据库操作信息）。 log4j.properties配置源码： 123456789log4j.rootLogger=info,appender1,appender2log4j.appender.appender1=org.apache.log4j.ConsoleAppender log4j.appender.appender2=org.apache.log4j.FileAppender log4j.appender.appender2.File=D:/logs/news/logFile.txtlog4j.appender.appender1.layout=org.apache.log4j.TTCCLayoutlog4j.appender.appender2.layout=org.apache.log4j.TTCCLayout jdbc配置文件中修改相关信息。jdbc.properties文件 1234567891011121314jdbc.driverClassName=oracle.jdbc.driver.OracleDriver //Oracle数据库jdbc.url=jdbc\:oracle\:thin\:@localhost\:1521\:jredu //数据库名jdbc.username=OnlineTest //数据库表jdbc.password=Jredu12345 //数据库密码jdbc.initialSize=0 jdbc.maxActive=20 jdbc.maxIdle=20 jdbc.minIdle=1 jdbc.maxWait=60000 最好自己动手配置一遍，记忆更深刻哦。 参考文档Spring声明式事务配置管理方法]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SSM项目配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试之Spring常用注解]]></title>
    <url>%2F2018%2F09%2F20%2Fjava%E9%9D%A2%E8%AF%95%E4%B9%8BSpring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Spring的一个核心功能是IOC，就是将Bean初始化加载到容器中，Bean是如何加载到容器的，可以使用Spring注解方式或者Spring XML配置方式。Spring注解方式减少了配置文件内容，更加便于管理，并且使用注解可以大大提高了开发效率！下面按照分类讲解Spring中常用的一些注解。 主键类注解@Component ：标准一个普通的spring Bean类。 @Repository：标注一个DAO组件类。 @Service：标注一个业务逻辑组件类。 @Controller：标注一个控制器组件类。 这些都是注解在平时的开发过程中出镜率极高，@Component、@Repository、@Service、@Controller实质上属于同一类注解，用法相同，功能相同，区别在于标识组件的类型。@Component可以代替@Repository、@Service、@Controller，因为这三个注解是被@Component标注的。 举例说明1）当一个组件代表数据访问层（DAO）的时候，我们使用@Repository进行注解，如下 1234567@Repositorypublic class HappyDaoImpl implements HappyDao&#123;private final static Logger LOGGER = LoggerFactory.getLogger(HappyDaoImpl .class);public void club()&#123; //do something ,like drinking and singing &#125;&#125; 2）当一个组件代表业务层时，我们使用@Service进行注解，如下 12345678910@Service(value="goodClubService")//使用@Service注解不加value ,默认名称是clubServicepublic class ClubServiceImpl implements ClubService &#123; @Autowired private ClubDao clubDao; public void doHappy()&#123; //do some Happy &#125; &#125; 3）当一个组件作为前端交互的控制层，使用@Controller进行注解，如下 123456789@Controllerpublic class HappyController &#123; @Autowired //下面进行讲解 private ClubService clubService; // Control the people entering the Club // do something&#125;/*Controller相关的注解下面进行详细讲解，这里简单引入@Controller*/ 总结注意点1、被注解的java类当做Bean实例，Bean实例的名称默认是Bean类的首字母小写，其他部分不变。@Service也可以自定义Bean名称，但是必须是唯一的！ 2、尽量使用对应组件注解的类替换@Component注解，在spring未来的版本中，@Controller，@Service，@Repository会携带更多语义。并且便于开发和维护！ 3、指定了某些类可作为Spring Bean类使用后，最好还需要让spring搜索指定路径，在Spring配置文件加入如下配置： 12&lt;!-- 自动扫描指定包及其子包下的所有Bean类 --&gt;&lt;context:component-scan base-package="org.springframework.*"/&gt; 装配bean时常用的注解@Autowired：属于Springorg.springframework.beans.factory.annotation包下,可用于为类的属性、构造器、方法进行注值@Resource：不属于spring的注解，而是来自于JSR-250位于java.annotation包下，使用该annotation为目标bean指定协作者Bean。@PostConstruct 和 @PreDestroy 方法 实现初始化和销毁bean之前进行的操作 举例说明1）：@Autowired源码123456@Target(&#123;ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Autowired &#123; boolean required() default true;&#125; 实例12345678910@Controllerpublic class HappyController &#123; @Autowired //默认依赖的ClubDao 对象（Bean）必须存在 //@Autowired(required = false) 改变默认方式 @Qualifier("goodClubService") private ClubService clubService; // Control the people entering the Club // do something&#125; 2）：@Resource源码123456@Target(&#123;TYPE, FIELD, METHOD&#125;)@Retention(RUNTIME)public @interface Resource &#123; String name() default ""; Class type() default java.lang.Object.class; ... 实例 12345678public class AnotationExp &#123; @Resource(name = "HappyClient") private HappyClient happyClient; @Resource(type = HappyPlayAno .class) private HappyPlayAno happyPlayAno;&#125; 总结1）：相同点@Resource的作用相当于@Autowired，均可标注在字段或属性的setter方法上。 2）：不同点 a：提供方 @Autowired是Spring的注解，@Resource是javax.annotation注解，而是来自于JSR-250，J2EE提供，需要JDK1.6及以上。b ：注入方式 @Autowired只按照Type 注入；@Resource默认按Name自动注入，也提供按照Type 注入；c：属性@Autowired注解可用于为类的属性、构造器、方法进行注值。默认情况下，其依赖的对象必须存在（bean可用），如果需要改变这种默认方式，可以设置其required属性为false。还有一个比较重要的点就是，@Autowired注解默认按照类型装配，如果容器中包含多个同一类型的Bean，那么启动容器时会报找不到指定类型bean的异常，解决办法是结合@Qualified注解进行限定，指定注入的bean名称。@Resource有两个中重要的属性：name和type。name属性指定byName，如果没有指定name属性，当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象，当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找依赖对象。需要注意的是，@Resource如果没有指定name属性，并且按照默认的名称仍然找不到依赖对象时， @Resource注解会回退到按类型装配。但一旦指定了name属性，就只能按名称装配了。 d：@Resource注解的使用性更为灵活，可指定名称，也可以指定类型 ；@Autowired注解进行装配容易抛出异常，特别是装配的bean类型有多个的时候，而解决的办法是需要在增加@Qualitied进行限定。 Spring中 @Autowired注解与@Resource注解的区别 注意点：使用@Resource也要注意添加配置文件到Spring，如果没有配置component-scan12&lt;context:component-scan&gt; &lt;!--&lt;context:component-scan&gt;的使用，是默认激活&lt;context:annotation-config&gt;功能--&gt; 则一定要配置 annotation-config 1&lt;context:annotation-config/&gt; @Component vs @Configuration and @Bean简单介绍Spring的官方团队说@Component可以替代 @Configuration注解，事实上我们看源码也可以发现看到，如下 123456@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Component //看这里！！！public @interface Configuration &#123; String value() default ""; 虽然说可以替代但是两个注解之间还是有区别的！Bean注解主要用于方法上，有点类似于工厂方法，当使用了@Bean注解，我们可以连续使用多种定义bean时用到的注解，譬如用@Qualifier注解定义工厂方法的名称，用@Scope注解定义该bean的作用域范围，譬如是singleton还是prototype等。 Spring 中新的 Java 配置支持的核心就是@Configuration 注解的类。这些类主要包括 @Bean 注解的方法来为 Spring 的 IoC 容器管理的对象定义实例，配置和初始化逻辑。 使用@Configuration 来注解类表示类可以被 Spring 的 IoC 容器所使用，作为 bean 定义的资源。 1234567@Configurationpublic class AppConfig &#123; @Bean public MyService myService() &#123; return new MyServiceImpl(); &#125;&#125; 这和 Spring 的 XML 文件中的非常类似 123&lt;beans&gt; &lt;bean id="myService" class="com.acme.services.MyServiceImpl"/&gt;&lt;/beans&gt; @Bean 注解扮演了和元素相同的角色。 举例说明@Component 和 @Configuration12345678910111213@Configurationpublic static class Config &#123; @Bean public SimpleBean simpleBean() &#123; return new SimpleBean(); &#125; @Bean public SimpleBeanConsumer simpleBeanConsumer() &#123; return new SimpleBeanConsumer(simpleBean()); &#125;&#125; @Componentpublic static class Config { @Bean public SimpleBean simpleBean() { return new SimpleBean(); } @Bean public SimpleBeanConsumer simpleBeanConsumer() { return new SimpleBeanConsumer(simpleBean()); } } 第一个代码正常工作，正如预期的那样，SimpleBeanConsumer将会得到一个单例SimpleBean的链接。第二个配置是完全错误的，因为Spring会创建一个SimpleBean的单例bean，但是SimpleBeanConsumer将获得另一个SimpleBean实例（也就是相当于直接调用new SimpleBean() ，这个bean是不归Spring管理的），既new SimpleBean() 实例是Spring上下文控件之外的。 总结使用@ configuration，所有标记为@ bean的方法将被包装成一个CGLIB包装器，它的工作方式就好像是这个方法的第一个调用，那么原始方法的主体将被执行，最终的对象将在spring上下文中注册。所有进一步的调用只返回从上下文检索的bean。在上面的第二个代码块中，新的SimpleBeanConsumer(simpleBean())只调用一个纯java方法。为了纠正第二个代码块，我们可以这样做 123456789101112131415@Componentpublic static class Config &#123; @Autowired SimpleBean simpleBean; @Bean public SimpleBean simpleBean() &#123; return new SimpleBean(); &#125; @Bean public SimpleBeanConsumer simpleBeanConsumer() &#123; return new SimpleBeanConsumer(simpleBean); &#125;&#125; Spring @Configuration vs @Component 基本概念：@Configuration 和@Bean spring MVC模块注解web模块常用到的注解@Controller ：表明该类会作为与前端作交互的控制层组件，通过服务接口定义的提供访问应用程序的一种行为，解释用户的输入，将其转换成一个模型然后将试图呈献给用户。 12345@Controllerpublic class HappyController &#123; //do something...&#125; Spring MVC 使用 @Controller 定义控制器，它还允许自动检测定义在类路径下的组件（配置文件中配置扫描路径）并自动注册。 @RequestMapping ： 这个注解用于将url映射到整个处理类或者特定的处理请求的方法。可以只用通配符！ 1234567891011121314151617@Controller@RequestMapping("/happy")public class HappyController &#123; @Autowired private HappyService happyService; @RequestMapping(/hello/*) public void sayHello()&#123; //请求为 /happy/hello/* 都会进入这个方法！ //例如：/happy/hello/123 /happy/hello/adb //可以通过get/post 请求 &#125; @RequestMapping(value="/haha",method=RequestMethod.GET) public void sayHaHa()&#123; //只能通过get请求 &#125; @RequestMapping 既可以作用在类级别，也可以作用在方法级别。当它定义在类级别时，标明该控制器处理所有的请求都被映射到 /favsoft 路径下。@RequestMapping中可以使用 method 属性标记其所接受的方法类型，如果不指定方法类型的话，可以使用 HTTP GET/POST 方法请求数据，但是一旦指定方法类型，就只能使用该类型获取数据。 @RequestParam ：将请求的参数绑定到方法中的参数上，有required参数，默认情况下，required=true，也就是改参数必须要传。如果改参数可以传可不传，可以配置required=false。 123456@RequestMapping("/happy") public String sayHappy( @RequestParam(value = "name", required = false) String name, @RequestParam(value = "age", required = true) String age) &#123; //age参数必须传 ，name可传可不传 &#125; @PathVariable ： 该注解用于方法修饰方法参数，会将修饰的方法参数变为可供使用的uri变量（可用于动态绑定）。 1234@RequestMapping(value="/happy/&#123;dayid&#125;",method=RequestMethod.GET)public String findPet(@PathVariable String dayid, Model mode) &#123;//使用@PathVariable注解绑定 &#123;dayid&#125; 到String dayid&#125; @PathVariable中的参数可以是任意的简单类型，如int, long, Date等等。Spring会自动将其转换成合适的类型或者抛出 TypeMismatchException异常。当然，我们也可以注册支持额外的数据类型。@PathVariable支持使用正则表达式，这就决定了它的超强大属性，它能在路径模板中使用占位符，可以设定特定的前缀匹配，后缀匹配等自定义格式。 123@RequestBody ： @RequestBody是指方法参数应该被绑定到HTTP请求Body上。@RequestMapping(value = "/something", method = RequestMethod.PUT)public void handle(@RequestBody String body，@RequestBody User user)&#123; //可以绑定自定义的对象类型} @ResponseBody ： @ResponseBody与@RequestBody类似，它的作用是将返回类型直接输入到HTTP response body中。@ResponseBody在输出JSON格式的数据时，会经常用到。 12345@RequestMapping(value = "/happy", method =RequestMethod.POST)@ResponseBodypublic String helloWorld() &#123; return "Hello World";//返回String类型&#125; @RestController ：控制器实现了REST的API，只为服务于JSON，XML或其它自定义的类型内容，@RestController用来创建REST类型的控制器，与@Controller类型。@RestController就是这样一种类型，它避免了你重复的写@RequestMapping与@ResponseBody。 @ModelAttribute ：@ModelAttribute可以作用在方法或方法参数上，当它作用在方法上时，标明该方法的目的是添加一个或多个模型属性（model attributes）。该方法支持与@RequestMapping一样的参数类型，但并不能直接映射成请求。控制器中的@ModelAttribute方法会在@RequestMapping方法调用之前而调用。 @ModelAttribute方法有两种风格：一种是添加隐形属性并返回它。另一种是该方法接受一个模型并添加任意数量的模型属性。用户可以根据自己的需要选择对应的风格。 Spring事务模块注解1、常用到的注解 在处理dao层或service层的事务操作时，譬如删除失败时的回滚操作。使用@Transactional 作为注解，但是需要在配置文件激活 12&lt;!-- 开启注解方式声明事务 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager" /&gt; 2、举例 12345678910111213@Servicepublic class CompanyServiceImpl implements CompanyService &#123; @Autowired private CompanyDAO companyDAO; @Transactional(propagation = Propagation.REQUIRED, readOnly = false, rollbackFor = Exception.class) public int deleteByName(String name) &#123; int result = companyDAO.deleteByName(name); return result; &#125; ...&#125; 总结事务的传播机制和隔离机制比较重要！) 一图学习 Spring事务传播性 readOnly : 事务的读写属性，取true或者false，true为只读、默认为falserollbackFor : 回滚策略，当遇到指定异常时回滚。譬如上例遇到异常就回滚timeout （补充的） : 设置超时时间，单位为秒isolation : 设置事务隔离级别，枚举类型，一共五种 透彻的掌握 Spring 中@transactional 的使用 Spring事务配置及事务的传播性与隔离级别详解 参考博文 spring 常用注解 详解Spring MVC 4常用的那些注解 史上最全最强SpringMVC详细示例实战教程]]></content>
  </entry>
  <entry>
    <title><![CDATA[java面试之Struts-Spring-Hibernate]]></title>
    <url>%2F2018%2F09%2F19%2Fjava%E9%9D%A2%E8%AF%95%E4%B9%8BStruts-Spring-Hibernate%2F</url>
    <content type="text"><![CDATA[在面试中一般面试官会根据面试者的简历来提问题，如果你的项目有用到ssh的话那么这篇文章也许会对你有帮助。当然，面试题目并不是速成法，如果你对这方面不太了解，建议你看我的另外一篇博客点我看基础接下来是我自己总结的一些ssh的面试题集合。 Struts面试题谈谈你对mvc的理解MVC是Model-View-Controler的简称。即模型-视图-控制器。MVC是一种设计模式，它强制性的把应用程序的输入.处理和输出分开。 MVC中的模型,视图.控制器他们分别担任着不同的任务。视图：视图是用户看到并与之交互的界面。视图向用户显示相关的数据，并接受用户的输入。视图不进行任何业务逻辑处理。模型： 模型表示业务数据和业务处理。相当于JavaBean。一个模型能为多个视图提供数据。这提高了应用程序的重用性。控制器：当用户单击web页面中的提交按钮时，控制器接受请求并调用相应的模型去处理请求。然后根据处理的结果调用相应的视图来显示处理的结果。MVC处理过程：首先控制器接受用户请求，调用相应的模型来进行业务处理，并返回数据给控制器，控制器调用相应的视图来显示处理的结果。并通过视图呈现给用户 说下Struts的设计模式MVC模式: web应用程序启动时就会加载并初始化ActionServler。用户提交表单时，一个配置好的ActionForm对象被创建，并被填入表单相应的数据，ActionServler根据Struts-config.xml文件配置好的设置决定是否需要表单验证，如果需要就调用ActionForm的Validate（）验证后选择将请求发送到哪个Action，如果Action不存在，ActionServlet会先创建这个对象，然后调用Action的execute（）方法。Execute（）从ActionForm对象中获取数据，完成业务逻辑，返回一个ActionForward对象，ActionServlet再把客户请求转发给ActionForward对象指定的jsp组件，ActionForward对象指定的jsp生成动态的网页，返回给客户。 Struts2.0常用标签 往action里传值：&lt;input name=&quot;userName&quot; type=&quot;text&quot; class=&quot;input6&quot; size=&quot;15&quot;&gt; 显示标签 property 用于输出指定值：&lt;s:property value=&quot;userName &quot;/&gt; 用于从页面往action中(user)的对象内传值：&lt;s:text name=&quot;user.userName &quot; id=&quot;username&quot;/&gt; 判断&lt;s:if&gt; &lt;/s:if&gt; 用于在页面中判断指定数据 &lt;s:if test=&quot;userName == admin&quot;&gt;…. &lt;/s:if&gt; &lt;s:else&gt;…. &lt;/s:else&gt; 迭代&lt;s:iterator&gt;用于将List、Map、ArrayList等集合进行循环遍历 123&lt;s:iterator value="userList" id="user" status="u"&gt; &lt;s:property value="userName"/&gt;&lt;/a&gt; &lt;/s:iterator&gt; URL地址标签，&lt;s:url&gt;用于生成一个URL地址，可以通过URL标签指定的&lt;s:param&gt;子元素向URL地址发送请求参数 123&lt;s:url action=" "&gt; &lt;s:param name=" " value=""&gt;&lt;/s:param&gt; &lt;/s:url&gt; 超链接 一般和&lt;s:url&gt;标签一起使用，用于带多个参数。 123456789101112&lt;a href=" &lt;s:url action=" "&gt; &lt;s:param name=" " value=""&gt;&lt;/s:param&gt; &lt;s:param name=" " value=""&gt;&lt;/s:param&gt; &lt;s:param name=" " value=""&gt;&lt;/s:param&gt; &lt;/s:url&gt; "&gt;超链接&lt;/a&gt; set标签，用于将某个值放入指定的范围内。例如application,session等。 1&lt;s:set name="user" value="userName" scope=”request”/&gt; Struts如何实现国际化 以下以两国语言(中文，英文)为例： 1. 在工程中加入Struts支持 2. 编辑ApplicationResource.properties文件,在其中加入要使用国际化的信息, 例如： lable.welcome.china=Welcome!!! 3. 创建英文资源文件ApplicationResource_en.properites 4. 创建临时中文资源文件ApplicationResource_temp.properites 例如：lable.welcom.china=中国欢迎您! 5. 对临时中文资源文件进行编码转换。可以使用myeclipse的插件,也可以在dos下执行: 1native2ascii -encoding gb2312 ApplicationResource_temp.properties ApplicationResource_zh_CN.properties 6.在jsp中加入struts的bean标记库 &lt;%@ taglib uri=”/WEB-INF/struts-bean.tld” prefix=”bean”%&gt;显示信息： &lt;bean:message key=”label.welcome.china”&gt;可以在struts-config.xml文件中定义多个资源包，而每个资源包可使用key属性指定包的名称 Struts1.x工作机制？工作机制：Struts的工作流程:在web应用启动时就会加载初始化ActionServlet,ActionServlet从struts-config.xml文件中读取配置信息,把它们存放到各种配置对象当ActionServlet接收到一个客户请求时,将执行如下流程.-(1)检索和用户请求匹配的ActionMapping实例,如果不存在,就返回请求路径无效信息;-(2)如果ActionForm实例不存在,就创建一个ActionForm对象,把客户提交的表单数据保存到ActionForm对象中;-(3)根据配置信息决定是否需要表单验证.如果需要验证,就调用ActionForm的validate()方法;-(4)如果ActionForm的validate()方法返回null或返回一个不包含ActionMessage的ActuibErrors对象, 就表示表单验证成功;-(5)ActionServlet根据ActionMapping所包含的映射信息决定将请求转发给哪个Action,如果相应的 Action实例不存在,就先创建这个实例,然后调用Action的execute()方法;-(6)Action的execute()方法返回一个ActionForward对象,ActionServlet在把客户请求转发给 ActionForward对象指向的JSP组件;-(7)ActionForward对象指向JSP组件生成动态网页,返回给客户; struts中怎么配置form-bean、action、tiles此处配置的是struts1.2的 123456789form-bean配置：(在配置文件struts-config.xml中)： &lt;form-beans &gt; &lt;form-bean name="" type=""&gt;&lt;/form-bean&gt; &lt;/form-beans&gt; name: 指定form的名字; type指定form的类型：包名+类名； action配置：(在配置文件struts-config.xml中) 12345678910111213141516171819&lt;action-mappings &gt; &lt;action path="" attribute="" input="" name="" parameter="" scope="request" type="" &gt;&lt;/action&gt; &lt;/action-mappings&gt; path：请求Action的名字; attribute：form的名字,与form-bean中的name对应; input：输入页的路径; name：如果配置了attribute,name不起作用,与attribute一样; parameter：使用分发Action时,指定调用分发Action中的 方法名; scope：Action的范围; type：Action的类型：包名+类名； tites配置： 新建一个 tiles-defs.xml文件,并在其中做如下配置： 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE tiles-definitions PUBLIC "-//Apache Software Foundation//DTD Tiles Configuration 1.1//EN" "http://jakarta.apache.org/struts/dtds/tiles-config_1_1.dtd"&gt; &lt;tiles-definitions&gt; &lt;definition name="member-definition" path="/Jsp/layout.jsp"&gt; &lt;put name="top" value="/mTop.do"/&gt; &lt;put name="left" value="/mLeft.do"/&gt; &lt;put name="main" value="/defaultMmain.do"/&gt; &lt;/definition&gt; &lt;/tiles-definitions&gt; 在web.xml和struts-config.xml和web.xml中做相应配置： 在struts-config.xml中配置如下 1234567&lt;plug-in className="org.apache.struts.tiles.TilesPlugin"&gt; &lt;set-property property="definitions-config" value="/WEB-INF/tiles-defs.xml"/&gt; &lt;set-property property="definitions-parser-validate" value="true"/&gt; &lt;/plug-in&gt; 在web.xml中配置如下：1234567&lt;init-param&gt; &lt;param-name&gt;definitions-config&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/tiles-defs.xml&lt;/param-value&gt; &lt;/init-param&gt; 调用Tiles组件 Tiles组件是通过Struts Action来调用的，在struts-config.xml中做如下action配置 1234567&lt;action path="/member" parameter="member-definition" type="org.apache.struts.actions.ForwardAction"/&gt; action是单实例还是多实例，为什么？ action是单实例的。当多个用户访问一个请求的时候，服务器内存中只有一个与之对应的action类对象。 因为当服务器第一次加载struts的配置文件的时候,创建了一个Action后,每发送一个请求,服务器都会先去检索相应的范围内(request,session)是否存在 这样一个action实例,如果存在,则使用这个实例,如果不存在,则创建一个action实例。 struts2.0的mvc模式？与struts1.0的区别? struts2的mvc模式：当用户在页面提交用户请求时,该请求需要提交给struts2的控制器处理。struts2的控制器根据处理结果, 决定将哪个页面呈现给客户端。 与struts1最大的不同是：struts2的控制器。struts2的控制器不再像struts1的控制器,需要继承一个Action父类,甚至可以无需实现 任何接口,struts2的Action就是一个普通的POJO。实际上，Struts2 的Action就是一个包含execute方法的普通Java类 该类里包含的多个属性用于封装用户的请求参数。 struts的处理流程一、ActionServlet的初始化ActionServlet作为Struts组件的前端控制器，由于web.xml的相应配置： 1&lt;load-on-startup&gt;0&lt;/load-on-startup&gt; 在应用一加载时即会被实例化并调用其init方法，init方法所做的主要工作有二： 加载struts配置文件，并创建用于封装配置信息的ModuleConfig对象 加载资源文件，并创建用于封装资源文件的MessageResources对象需要注意两点：如果web.xml有多模块配置，将创建多个ModuleConfig对象和MessageResources对象分别用于封装各个模块的struts配置文件和资源文件。针对各个模块所创建的ModuleConfig对象和MessageResources对象将存储在ServletContext中，对应的属性名中有该模块名称的相应标识。另外，如果有相应配置的话，init方法还将初始化数据源和PlugIn二、ActionServlet的process所有形如*.do的请求（根据web.xml中的相关配置）将提交给ActionServlet，最终将调用其process方法。process方法的主要工作有三：1.根据请求信息获知所请求的模块名称，从ServletContext中获得与请求模块对应的的ModuleConfig对象，并存储到request中。2.根据模块信息获得相应的RequestProcessor对象，一个模块对应一个RequestProcessor对象，RequestProcessor对象将关联与所属模块对应的ModuleConfig对象。3.调用RequestProcessor对象的process方法，将request和response作为参数传递给它。三、RequestProcessor的processRequestProcessor对象的process方法的主要工作有五步：1.调用自己的 processPreprocess(request, response)方法，该方法不进行任何操作，用于子类重写扩展其功能。2.获得与请求地址所匹配的ActionMapping对象，AcionMapping对象用于封装一个特定acion的配置信息。3.根据ActionMapping中的配置信息获得ActionForm对象（该对象将缓存到request或session中），并将表单数据填充到ActionForm中，然后根据ActionMapping的配置决定是否验证ActionForm，如果验证，将调用ActionForm的 validate方法，若其返回的ActionErros对象中包含ActionMessage对象则表示验证失败，将转向action配置信息 input属性所指示的地址。4.如果ActionForm无需验证或验证通过将创建并缓存与请求地址匹配的Action对象，将ActionMapping对象、ActionForm对象、request和response作为参数调用其execute方法。5.根据Action对象的execute方法返回的ActionForward对象，将请求转发或重定向到该ActionForward所封装的地址。Struts/webwork 的工作机制，它有哪些标签Struts 2框架的大致处理流程如下：浏览器发送请求，例如请求/mypage.action、/reports/myreport.pdf等。核心控制器FilterDispatcher根据请求决定调用合适的Action。WebWork的拦截器链自动对请求应用通用功能，例如workflow、validation或文件上传等功能。回调Action的execute方法，该execute方法先获取用户请求参数，然后执行某种数据库操作，既可以是将数据保存到数据库，也可以从数据库中检索信息。实际上，因为Action只是一个控制器，它会调用业务逻辑组件来处理用户的请求。Action的execute方法处理结果信息将被输出到浏览器中，可以是HTML页面、图像，也可以是PDF文档或者其他文档。此时支持的视图技术非常多，既支持JSP，也支持Velocity、FreeMarker等模板技术。 Spring部分Spring工作机制1.spring mvc请所有的请求都提交给DispatcherServlet,它会委托应用系统的其他模块负责负责对请求进行真正的处理工作。2.DispatcherServlet查询一个或多个HandlerMapping,找到处理请求的Controller.3.DispatcherServlet请请求提交到目标Controller4.Controller进行业务逻辑处理后，会返回一个ModelAndView5.Dispathcher查询一个或多个ViewResolver视图解析器,找到ModelAndView对象指定的视图对象6.视图对象负责渲染返回给客户端。 ##使用Spring的好处AOP 让开发人员可以创建非行为性的关注点，称为横切关注点，并将它们插入到应用程序代码中。使用 AOP 后，公共服务 （比 如日志、持久性、事务等）就可以分解成方面并应用到域对象上，同时不会增加域对象的对象模型的复杂性。 1234&lt;bean id = "proxy" type = "org.spring.framework.aop.ProxyBeanFacory"&gt;&lt;property name = "target" ref = ""&gt;&lt;/property&gt;&lt;property name = "advisor" ref = ""&gt;&lt;/property&gt;&lt;/bean&gt; IOC 允许创建一个可以构造对象的应用环境，然后向这些对象传递它们的协作对象。正如单词 倒置 所表明的，IOC 就像反 过来的 JNDI。没有使用一堆抽象工厂、服务定位器、单元素（singleton）和直接构造（straight construction），每一个对象都是用其协作对象构造的。因此是由容器管理协作对象（collaborator）。 Spring即是一个AOP框架，也是一IOC容器。 Spring 最好的地方是它有助于您替换对象。有了 Spring，只要用 JavaBean 属性和配置文件加入依赖性（协作对象）。然后可以很容易地在需要时替换具有类似接口的协作对象。 Spring是什么?根据你的理解详细谈谈你的见解◆目的：解决企业应用开发的复杂性 ◆功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能 ◆范围：任何Java应用 简单来说，Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。 ◆轻量——从大小与开销两方面而言Spring都是轻量的。完整的Spring框架可以在一个大小只有1MB多的JAR文件里发布。并且Spring所需的处理开销也是微不足道的。此外，Spring是非侵入式的：典型地，Spring应用中的对象不依赖于Spring的特定类。 ◆控制反转——Spring通过一种称作控制反转（IoC）的技术促进了松耦合。当应用了IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。你可以认为IoC与JNDI相反——不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它。 ◆面向切面——Spring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（）管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。 ◆容器——Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。然而，Spring不应该被混同于传统的重量级的EJB容器，它们经常是庞大与笨重的，难以使用。 ◆框架——Spring可以将简单的组件配置、组合成为复杂的应用。在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。Spring也提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。 所有Spring的这些特征使你能够编写更干净、更可管理、并且更易于测试的代码。它们也为Spring中的各种模块提供了基础支持。 spring在项目中如何充当粘合剂 1、在项目中利用spring的IOC(控制反转或依赖注入),明确地定义组件接口(如UserDAO)，开发者可以独立开发各个组件, 然后根据组件间的依赖关系组装(UserAction依赖于UserBiz,UserBiz依赖于UserDAO)运行，很好的把Struts(Action)和hibernate(DAO的实现)结合起来了。 2、spring的事务管理把hibernate对数据库的操作进行了事务配置。 spring的事务如何配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 spring的声明式事务配置： 1. &lt;!-- 配置sessionFactory --&gt;&lt;bean id="sessionFactory"class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt;&lt;property name="configLocation"&gt;&lt;value&gt;/WEB-INF/classes/hibernate.cfg.xml&lt;/value&gt;&lt;/property&gt;&lt;/bean&gt; 2. 配置事务管理器 &lt;!-- 配置事务管理器 --&gt;&lt;bean id="transactionManager"class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt;&lt;property name="sessionFactory"&gt;&lt;ref local="sessionFactory" /&gt;&lt;/property&gt;&lt;/bean&gt; 3. 配置事务特性 &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt;&lt;tx:attributes&gt; &lt;tx:method name="add*" propagation="REQUIRED"/&gt; &lt;tx:method name="update*" propagation="REQUIRED"/&gt; &lt;tx:method name="del*" propagation="REQUIRED"/&gt; &lt;tx:method name="*" read-only="true"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; 4. 配置哪些类的哪些方法配置事务 &lt;aop:config&gt; &lt;aop:pointcut id="allManagerMethod" ession="execution(* com.yyaccp.service.impl.*.*(..))"/&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="allManagerMethod"&gt; &lt;/aop:config&gt; transaction有那几种实现在Spring中，事务处理主要有两种方式(1) 代码控制事务在程序中引入新的模版类，这个类封装了事务管理的功能(2) 参数配置控制事务,在Application-Context.xml增加一个事务代理（UserDAOProxy）配置IBATIS中的事物属性怎么配置SQL MAP XML配置文件中的transactionManager Hibernate面试题Hibernate工作原理1.读取并解析配置文件 2.读取并解析映射信息，创建SessionFactory 3.打开Sesssion 4.创建事务Transation 5.持久化操作 6.提交事务 7.关闭Session 8.关闭SesstionFactory 什么是Hibernate的并发机制？怎么处理并发问题？Hibernate并发机制： a、Hibernate的Session对象是非线程安全的,对于单个请求,单个会话,单个的工作单元(即单个事务,单个线程),它通常只使用一次,然后就丢弃。如果一个Session 实例允许共享的话，那些支持并发运行的,例如Http request,session beans将会导致出现资源争用。如果在Http Session中有hibernate的Session的话,就可能会出现同步访问Http Session。只要用户足够快的点击浏览器的“刷新”,就会导致两个并发运行的线程使用同一个Session。 b、多个事务并发访问同一块资源,可能会引发第一类丢失更新，脏读，幻读，不可重复读，第二类丢失更新一系列的问题。 解决方案：设置事务隔离级别。 Serializable：串行化。隔离级别最高 Repeatable Read：可重复读 Read Committed：已提交数据读 Read Uncommitted：未提交数据读。隔离级别最差 设置锁：乐观锁和悲观锁。 乐观锁：使用版本号或时间戳来检测更新丢失,在的映射中设置 optimistic-lock=”all”可以在没有版本或者时间戳属性映射的情况下实现 版本检查，此时Hibernate将比较一行记录的每个字段的状态 行级悲观锁：Hibernate总是使用数据库的锁定机制，从不在内存中锁定对象！只要为JDBC连接指定一下隔 离级别，然后让数据库去搞定一切就够了。类LockMode 定义了Hibernate所需的不同的锁定级别：LockMode.UPGRADE,LockMode.UPGRADE_NOWAIT,LockMode.READ; Hibernate自带的分页机制是什么？如果不使用Hibernate自带的分页，则采用什么方式分页？ 1、hibernate自带的分页机制：获得Session对象后，从Session中获得Query对象。用Query.setFirstResult()：设置要显示的第一行数据Query.setMaxResults()：设置要显示的最后一行数据。 2、不使用hibernate自带的分页,可采用sql语句分页， 如：5:为每页显示的记录,2为当前页： select * top 5 from table where tabId not in (select tabId top (2-1)*5 from table); hibernate的三种状态之间如何转换 当对象由瞬时状态(Transient)一save()时，就变成了持久化状态。 当我们在Session里存储对象的时候，实际是在Session的Map里存了一份， 也就是它的缓存里放了一份，然后，又到数据库里存了一份，在缓存里这一份叫持久对象(Persistent)。 Session 一 Close()了，它的缓存也都关闭了，整个Session也就失效了， 这个时候，这个对象变成了游离状态(Detached)，但数据库中还是存在的。当游离状态(Detached)update()时，又变为了持久状态(Persistent)。当持久状态(Persistent)delete()时，又变为了瞬时状态(Transient),此时，数据库中没有与之对应的记录。 update（）和saveOrUpdate（）的区别？ update()和saveOrUpdate()是用来对跨Session的PO进行状态管理的,update()方法操作的对象必须是持久化了的对象。也就是说，如果此对象在数据库中不存在的话，就不能使用update()方法。 saveOrUpdate()方法操作的对象既可以使持久化了的，也可以使没有持久化的对象。如果是持久化了的对象调用saveOrUpdate()则会 更新数据库中的对象；如果是未持久化的对象使用此方法,则save到数据库中。 hibernate拒绝连接、服务器崩溃的原因？最少写5个 db没有打开 网络连接可能出了问题 连接配置错了 驱动的driver，url是否都写对了 LIB下加入相应驱动，数据连接代码是否有误 数据库配置可能有问题 当前联接太多了，服务器都有访问人数限制的 服务器的相应端口没有开，即它不提供相应的服务 hibernate有哪些缓存，分别怎么使用? 你对hibernate的了解到了一个什么样的程度？ 写出一个sql语句体现hibernate中一对多的关系 hibernate如何管理缓存 Hibernate 中提供了两级Cache，第一级别的缓存是Session级别的缓存，它是属于事务范围的缓存。这一级别的缓存由hibernate管理的，一般情况下无需进行干预；第二级别的缓存是SessionFactory级别的缓存，它是属于进程范围或群集范围的缓存。这一级别的缓存可以进行配置和更改，并且可以动态加载和卸载。 Hibernate还为查询结果提供了一个查询缓存，它依赖于第二级缓存。 1. 一级缓存和二级缓存的比较：第一级缓存 第二级缓存 存放数据的形式 相互关联的持久化对象 对象的散装数据 缓存的范围 事务范围，每个事务都有单独的第一级缓存进程范围或集群范围，缓存被同一个进程或集群范围内的所有事务共享 并发访问策略由于每个事务都拥有单独的第一级缓存，不会出现并发问题，无需提供并发访问策略由于多个事务会同时访问第二级缓存中相同数据，因此必须提供适当的并发访问策略，来保证特定的事务隔离级别 数据过期策略没有提供数据过期策略。处于一级缓存中的对象永远不会过期，除非应用程序显式清空缓存或者清除特定的对象必须提供数据过期策略，如基于内存的缓存中的对象的最大数目，允许对象处于缓存中的最长时间，以及允许对象处于缓存中的最长空闲时间 物理存储介质内存内存和硬盘。对象的散装数据首先存放在基于内在的缓存中，当内存中对象的数目达到数据过期策略中指定上限时，就会把其余的对象写入基于硬盘的缓存中。缓存的软件实现 在Hibernate的Session的实现中包含了缓存的实现由第三方提供，Hibernate仅提供了缓存适配器(CacheProvider)。用于把特定的缓存插件集成到Hibernate中。启用缓存的方式只要应用程序通过Session接口来执行保存、更新、删除、加载和查询数据库数据的操作，Hibernate就会启用第一级缓存，把数据库中的数据以对象的形式拷贝到缓存中，对于批量更新和批量删除操作，如果不希望启用第一级缓存，可以绕过Hibernate API，直接通过JDBC API来执行指操作。用户可以在单个类或类的单个集合的粒度上配置第二级缓存。如果类的实例被经常读但很少被修改，就可以考虑使用第二级缓存。只有为某个类或集合配置了第二级缓存，Hibernate在运行时才会把它的实例加入到第二级缓存中。 用户管理缓存的方式第一级缓存的物理介质为内存，由于内存容量有限，必须通过恰当的检索策略和检索方式来限制加载对象的数目。Session的evit()方法可以显式清空缓存中特定对象，但这种方法不值得推荐。 第二级缓存的物理介质可以是内存和硬盘，因此第二级缓存可以存放大量的数据，数据过期策略的maxElementsInMemory属性值可以控制内存中的对象数目。管理第二级缓存主要包括两个方面：选择需要使用第二级缓存的持久类，设置合适的并发访问策略：选择缓存适配器，设置合适的数据过期策略。 2. 一级缓存的管理： 当应用程序调用Session的save()、update()、savaeOrUpdate()、get()或load()，以及调用查询接口的 list()、iterate()或filter()方法时，如果在Session缓存中还不存在相应的对象，Hibernate就会把该对象加入到第一级缓存中。当清理缓存时，Hibernate会根据缓存中对象的状态变化来同步更新数据库。 Session为应用程序提供了两个管理缓存的方法： evict(Object obj)：从缓存中清除参数指定的持久化对象。 clear()：清空缓存中所有持久化对象。 3. 二级缓存的管理： 3.1. Hibernate的二级缓存策略的一般过程如下： 1) 条件查询的时候，总是发出一条select * from table_name where …. （选择所有字段）这样的SQL语句查询数据库，一次获得所有的数据对象。 2) 把获得的所有数据对象根据ID放入到第二级缓存中。 3) 当Hibernate根据ID访问数据对象的时候，首先从Session一级缓存中查；查不到，如果配置了二级缓存，那么从二级缓存中查；查不到，再查询数据库，把结果按照ID放入到缓存。 4) 删除、更新、增加数据的时候，同时更新缓存。 Hibernate的二级缓存策略，是针对于ID查询的缓存策略，对于条件查询则毫无作用。为此，Hibernate提供了针对条件查询的Query Cache。 3.2. 什么样的数据适合存放到第二级缓存中？ 1 很少被修改的数据 2 不是很重要的数据，允许出现偶尔并发的数据 3 不会被并发访问的数据 4 参考数据,指的是供应用参考的常量数据，它的实例数目有限，它的实例会被许多其他类的实例引用，实例极少或者从来不会被修改。 3.3. 不适合存放到第二级缓存的数据？ 1 经常被修改的数据 2 财务数据，绝对不允许出现并发 3 与其他应用共享的数据。 3.4. 常用的缓存插件 Hibernater 的二级缓存是一个插件，下面是几种常用的缓存插件： EhCache：可作为进程范围的缓存，存放数据的物理介质可以是内存或硬盘，对Hibernate的查询缓存提供了支持。 OSCache：可作为进程范围的缓存，存放数据的物理介质可以是内存或硬盘，提供了丰富的缓存数据过期策略，对Hibernate的查询缓存提供了支持。 SwarmCache：可作为群集范围内的缓存，但不支持Hibernate的查询缓存。 JBossCache：可作为群集范围内的缓存，支持事务型并发访问策略，对Hibernate的查询缓存提供了支持。 3.5. 配置二级缓存的主要步骤： 1) 选择需要使用二级缓存的持久化类，设置它的命名缓存的并发访问策略。这是最值得认真考虑的步骤。 2) 选择合适的缓存插件，然后编辑该插件的配置文件。 使用Hibernate的优点： 对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。 Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作 hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。 hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。 Hibernate是如何延迟加载? Hibernate2延迟加载实现：a)实体对象 b)集合（Collection） Hibernate3 提供了属性的延迟加载功能当Hibernate在查询数据的时候，数据并没有存在与内存中，当程序真正对数据的操作时，对象才存在与内存中，就实现了延迟加载，他节省了服务器的内存开销，从而提高了服务器的性能。 如何优化Hibernate？1.使用双向一对多关联，不使用单向一对多 2.灵活使用单向一对多关联 3.不用一对一，用多对一取代 4.配置对象缓存，不使用集合缓存 5.一对多集合使用Bag,多对多集合使用Set 继承类使用显式多态 表字段要少，表关联不要怕多，有二级缓存撑腰 综合考察Hibernate和spring中常出现的几个异常1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'sessionFactory' defined in ServletContext resource [/WEB-INF/applicationContext.xml]: Initialization of bean failed; nested exception is org.hibernate.MappingException: Repeated column in mapping for entity: com.xindeco.myregister.pojo.MyRegisterInfo column: password (should be mapped with insert="false" update="false") 出错原因：password 和repassword同时对应数据库表中的password一列，同时password里面的update和insert都设为true。xml文件如下： &lt;property name="password" type="java.lang.String" update="true" insert="true" access="property" column="password" length = "32" /&gt; &lt;property name="repassword" type="java.lang.String" update="false" insert="false" access="property" column="password" length = "32" /&gt; 解决方法：将repassword的insert和update设为false。 org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'sessionFactory' defined in ServletContext resource [/WEB-INF/applicationContext.xml]: Initialization of bean failed;nested exception is org.hibernate.PropertyNotFoundException: Could not find a getter for ID in class 错误原因：hibernate的映射文件中ID是大写的，而pojo的类中id是小写的 解决方法：要么将pojo类中的id改称大写，要么把hibernate的映射文件中的ID改称小写。 Hibernate与jdbc的联系hibernate是jdbc的轻量级封装，包括jdbc的与数据库的连接（用hibernate.property的配置文件实现当然本质是封装了jdbc的forname），和查询，删除等代码，都用面向对象的思想用代码联系起来，hibernate通过hbm 配置文件把po类的字段和数据库的字段关联起来比如数据库的id, 在po类中就是pravite Long id; public Long getId() ;public setId(Long id);然后hql语句也是面向对象的，它的查询语句不是查询数据库而是查询类的,这些实现的魔法就是xml文件，其实hibernate=封装的jdbc+xml文件。 Hibernate与spring的联系hibernate中的一些对象可以给Spring来管理,让Spring容器来创建hibernate中一些对象实例化。例如：SessionFactory，HibernateTemplate等。Hibernate本来是对数据库的一些操作,放在DAO层,而Spring给业务层的方法定义了事务,业务层调用DAO层的方法,很好的将Hibernate的操作也加入到事务中来了。 项目中为什么使用SSH 使用Struts是因为struts是基于MVC模式的,很好的将应用程序进行了分层，使开发者更关注于业务逻辑的实现；第二，struts有着丰富的taglib,如能灵活运用，则能大大提高开发效率。 使用Hibernate：因为hibernate为Java应用提供了一个易用的、高效率的对象关系映射框架。hibernate是个轻量级的持久性框架，功能丰富。 使用Spring：因为spring基于IoC(Inversion of Control，反向控制)和AOP构架多层j2ee系统的框架，但它不强迫你必须在每一层中必须使用Spring，因为它模块化的很好，允许你根据自己的需要选择使用它的某一个模块； 采用IoC使得可以很容易的实现bean的装配，提供了简洁的AOP并据此实现事务管理(Transcation Managment),等等]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础面试之语法之一]]></title>
    <url>%2F2018%2F09%2F18%2Fjava%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%AF%AD%E6%B3%95%E4%B9%8B%E4%B8%80%2F</url>
    <content type="text"><![CDATA[对于Java面试来说的本文只是对Java基础知识的一个小结，并不是什么武功秘籍或者什么速成法，更多的要求面试者自己脚踏实地的去学，多看书，多敲代码，多去思考，才是面试的王者之道。在这里作者提供了Java官方的API以供大家参考和学习[点我去官方API] 一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？一个“.java”源文件里面可以包含多个类，但是只允许有一个public类，并且类名必须和文件名一致。每个编译单元只能有一个public 类。这么做的意思是，每个编译单元只能有一个公开的接口，而这个接口就由其public 类来表示。你可以根据需要，往这个文件里面添加任意多个提供辅助功能的package 权限的类。但是如果这个编译单元里面有两个或两个以上的public 类的话，程序就不知道从哪里导入了，编译器就会报错。 &amp;和&amp;&amp;的区别&amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。 &amp;&amp;还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式，例如，对于if(str != null&amp;&amp; !str.equals(“”))表达式，当str为null时，后面的表达式不会执行，所以不会出现NullPointerException如果将&amp;&amp;改为&amp;，则会抛出NullPointerException异常。If(x==33 &amp;++y&gt;0) y会增长，If(x==33 &amp;&amp; ++y&gt;0)不会增长 &amp;还可以用作位运算符，当&amp;操作符两边的表达式不是boolean类型时，&amp;表示按位与操作，我们通常使用0x0f来与一个整数进行&amp;运算，来获取该整数的最低4个bit位，例如，0x31 &amp; 0x0f的结果为0x01。 备注：这道题先说两者的共同点，再说出&amp;&amp;和&amp;的特殊之处，并列举一些经典的例子来表明自己理解透彻深入、实际经验丰富。 下面的例子更清楚y增长 y没有增长 在JAVA中如何跳出当前的多重嵌套循环？在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break语句，即可跳出外层循环。例如， 并不推荐这种方式，让外层的循环条件表达式的结果可以受到里层循环体代码的控制，跳出本层循环 switch语句能否作用在byte上，能否作用在long上，能否作用在String上?在switch（expr1）中，expr1只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是int基本类型或Integer包装类型，由于，byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。显然，long符合switch的语法规定，并且不能被隐式转换成int类型，所以，它不能作用于swtich语句中。 short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?对于short s1 = 1; s1 += 1;由于 +=是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。 char型变量中能不能存贮一个中文汉字?为什么?当然是可以了，char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字。补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。 8、用最有效率的方法算出2乘以8等於几?2&lt;&lt;3,位移三位就可以了，而位运算cpu直接支持的，效率最高。 int和Integer有什么区别？Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。Java 为每个原始类型提供了包装类型： 原始类型: boolean，char，byte，short，int，long，float，double 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double 第二种情况 解释内存中的栈(stack)、堆(heap)和静态区(static area)的用法。通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；而通过new关键字和构造器创建的对象放在堆空间；程序中的字面量（literal）如直接书写的100、”hello”和常量都是放在静态区中。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，理论上整个内存没有被其他进程使用的空间甚至硬盘上的虚拟内存都可以被当成堆空间来使用。String str = new String(“hello”);上面的语句中变量str放在栈上，用new创建出来的字符串对象放在堆上，而”hello”这个字面量放在静态区。 数组有没有length()方法？String有没有length()方法？这个问题代码敲多了都应该知道，数组本身就有长度，String字符串则需要length方法来获取长度 构造器（constructor）是否可被重写（override）？构造器不能被继承，因此不能被重写，但可以被重载。 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的：(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；(2)如果两个对象的hashCode相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。补充：关于equals和hashCode方法，很多Java程序都知道，但很多人也就是仅仅知道而已，在Joshua Bloch的大作《Effective Java》（很多软件公司，《Effective Java》、《Java编程思想》以及《重构：改善既有代码质量》是Java程序员必看书籍，如果你还没看过，那就赶紧去亚马逊买一本吧）中是这样介绍equals方法的：首先equals方法必须满足自反性（x.equals(x)必须返回true）、对称性（x.equals(y)返回true时，y.equals(x)也必须返回true）、传递性（x.equals(y)和y.equals(z)都返回true时，x.equals(z)也必须返回true）和一致性（当x和y引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值），而且对于任何非null值的引用x，x.equals(null)必须返回false。实现高质量的equals方法的诀窍包括：1. 使用==操作符检查”参数是否为这个对象的引用”；2. 使用instanceof操作符检查”参数是否为正确的类型”；3. 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；4. 编写完equals方法后，问自己它是否满足对称性、传递性、一致性；5. 重写equals时总是要重写hashCode；6. 不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解。 是否可以继承String类？String 类是final类，不可以被继承。 补充：继承String本身就是一个错误的行为，对String类型最好的重用方式是关联关系（Has-A）和依赖关系（Use-A）而不是继承关系（Is-A）。 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？是值传递。Java语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。 String和StringBuilder、StringBuffer的区别？Java平台提供了两种类型的字符串：String和StringBuffer/StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer/StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是Java 5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer要高。 什么情况下用+运算符进行字符串连接比调用StringBuffer/StringBuilder对象的append方法连接字符串性能更好？string旦赋值或实例化后就不可更改，如果赋予新值将会重新开辟内存地址进行存储。而StringBuffer类使用append和insert等方法改变字符串值时只是在原有对象存储的内存地址上进行连续操作，减少了资源的开销 因此我们得出结论：当需要进行频繁修改字符串的操作时先建立StringBuffer类对象进行操作，将最后结果转化成String类对象返回，这样效率会高很多。 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。 面试题：华为的面试题中曾经问过这样一个问题 – “为什么不能根据返回类型来区分重载”，快说出你的答案吧！因为调用时不能指定类型信息，编译器不知道你要调用哪个函数。float max(int a, int b); int max(int a, int b); 描述一下JVM加载class文件的原理机制？JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。 由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。 类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。 当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明： Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。 抽象类（abstract class）和接口（interface）有什么异同？抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。 静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化，其语法看起来挺诡异的。 Java 中会存在内存泄漏吗，请简单描述。理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收，因此也会导致内存泄露的发生。例如hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。下面例子中的代码也会导致内存泄露。 抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。 阐述静态变量和实例变量的区别。静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。 静态变量是所有对象共有的，某一个对象将它的值改变了，其他对象再去获取它的值，得到的是改变后的值；实例变量则是每一个对象私有的，某一个对象将它的值改变了，不影响其他对象取值的结果，其他对象仍会得到实例变量一开始就被赋予的值。例： 1234567891011121314151617public class A&#123;static int a = 0; // 这是静态变量int b = 0; // 这是实例变量&#125; public class B&#123;public static void main (String[] args)&#123;A a1 = new A();A a2 = new A();a1.a = 3; // 对象a1将3赋值给aa1.b = 4 ; // 对象a1将4赋值给“它自己的b”System.out.println(a2.a); //结果为3 //静态变量是针对所有对象的，所以a1改变a的值，a2获取到的a的值也改变了的System.out.println(a2.b); //结果为0 //实例变量只改变自身所获取的值，所以a1获取的b的值改变了，不影响a2获取的b的值 &#125;&#125; GC是什么？为什么要有GC？GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显示的垃圾回收调用。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在Java诞生初期，垃圾回收是Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今Java的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得iOS的系统比Android系统有更好的用户体验，其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显示的垃圾回收调用。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在Java诞生初期，垃圾回收是Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今Java的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得iOS的系统比Android系统有更好的用户体验，其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。与垃圾回收相关的JVM参数： 12345678910-Xms / -Xmx — 堆的初始大小 / 堆的最大大小-Xmn — 堆中年轻代的大小-XX:-DisableExplicitGC — 让System.gc()不产生任何作用-XX:+PrintGCDetails — 打印GC的细节-XX:+PrintGCDateStamps — 打印GC操作的时间戳-XX:NewSize / XX:MaxNewSize — 设置新生代大小/新生代最大大小-XX:NewRatio — 可以设置老生代和新生代的比例-XX:PrintTenuringDistribution — 设置每次新生代GC后输出幸存者乐园中对象年龄的分布-XX:InitialTenuringThreshold / -XX:MaxTenuringThreshold：设置老年代阀值的初始值和最大值-XX:TargetSurvivorRatio：设置幸存区的目标使用率 String s = new String(“xyz”);创建了几个字符串对象？两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。 接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？接口可以继承接口，而且支持多重继承。抽象类可以实现(implements)接口，抽象类可继承具体类也可以继承抽象类。 Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？匿名的内部类不能extends（继承）其它类，但一个内部类可以作为一个接口，由另一个内部类实现。 12345678910111213141516171819202122232425262728293031323334353637class Car&#123; void move()&#123;&#125;&#125;interface Person&#123; void learn();&#125;abstract class Animal&#123; abstract void eat();&#125;public class AnonymousInnerClassDemo &#123; public static void main(String[] args) &#123; Car car = new Car()&#123; @Override void move() &#123; System.out.println("匿名内部类的move方法"); &#125; &#125;; car.move(); Person person = new Person() &#123; public void learn() &#123; System.out.println("匿名内部类的learn方法"); &#125; &#125;; person.learn(); Animal animal = new Animal() &#123; @Override void eat() &#123; System.out.println("匿名内部类的eat方法"); &#125; &#125;; animal.eat(); &#125;&#125; 指出下面程序的运行结果。执行结果：1a2b2b。创建对象时构造器的调用顺序是：先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。如果不能给出此题的正确答案，说明之前Java类加载机制还没有完全理解，赶紧再看看吧。 数据类型之间的转换： 如何将字符串转换为基本数据类型？ 如何将基本数据类型转换为字符串？调用基本数据类型对应的包装类中的方法parseXXX(String)或valueOf(String)即可返回相应基本类型； 一种方法是将基本数据类型与空字符串（””）连接（+）即可获得其所对应的字符串；另一种方法是调用String 类中的valueOf()方法返回相应字符串Character ch2 = ‘8’; （char是基本数据类型，Character是其包装类型。） int num2 = Integer.parseInt(ch2.toString()); 如何实现字符串的反转及替换？递归实现字符串反转 日期和时间： 如何取得年月日、小时分钟秒？ 如何取得从1970年1月1日0时0分0秒到现在的毫秒数？ 如何取得某月的最后一天？ 如何格式化日期？创建java.util.Calendar 实例，调用其get()方法传入不同的参数即可获得参数所对应的值。Java 8中可以使用java.time.LocalDateTimel来获取，代码如下所示。 以下方法均可获得该毫秒数。 Calendar.getInstance().getTimeInMillis(); System.currentTimeMillis(); Clock.systemDefaultZone().millis(); // Java 8 取得某月的最后一天 利用java.text.DataFormat 的子类（如SimpleDateFormat类）中的format(Date)方法可将日期格式化。Java 8中可以用java.time.format.DateTimeFormatter来格式化时间日期，代码如下所示。 打印昨天的当前时刻。 比较一下Java和JavaSciprt。基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身提供了非常丰富的内部对象供设计人员使用。 解释和编译：Java的源代码在执行之前，必须经过编译。JavaScript是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。（目前的浏览器几乎都使用了JIT（即时编译）技术来提升JavaScript的运行效率） 强类型变量和类型弱变量：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript的解释器在运行时检查推断其数据类型。 代码格式不一样。补充：上面列出的四点是网上流传的所谓的标准答案。其实Java和JavaScript最重要的区别是一个是静态语言，一个是动态语言。目前的编程语言的发展趋势是函数式语言和动态语言。在Java中类（class）是一等公民，而JavaScript中函数（function）是一等公民，因此JavaScript支持函数式编程，可以使用Lambda函数和闭包（closure），当然Java 8也开始支持函数式编程，提供了对Lambda表达式以及函数式接口的支持。对于这类问题，在面试的时候最好还是用自己的语言回答会更加靠谱，不要背网上所谓的标准答案。 Error和Exception有什么区别？Error表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。 提示：用递归编写程序时一定要牢记两点：1. 递归公式；2. 收敛条件（什么时候就不再继续递归）。 try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后?会执行，在方法返回调用者前执行。注意：在finally中改变返回值的做法是不好的，因为如果存在finally代码块，try中的return语句不会立马返回调用者，而是记录下返回值待finally代码块执行完毕之后再向调用者返回其值，然后如果在finally中修改了返回值，就会返回修改后的值。显然，在finally中返回或者修改返回值会对程序造成很大的困扰，C#中直接用编译错误的方式来阻止程序员干这种龌龊的事情，Java中也可以通过提升编译器的语法检查级别来产生警告或错误，Eclipse中可以在如图所示的地方进行设置，强烈建议将此项设置为编译错误。 Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是Throwable类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；try用来指定一块预防所有异常的程序；catch子句紧跟在try块后面，用来指定你想要捕获的异常的类型；throw语句用来明确地抛出一个异常；throws用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；finally为确保一段代码不管发生什么异常状况都要被执行；try语句可以嵌套，每当遇到一个try语句，异常的结构就会被放入异常栈中，直到所有的try语句都完成。如果下一级的try语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这种异常的try语句或者最终将异常抛给JVM。 运行时异常与受检异常有何异同？异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，在Effective Java中对异常的使用给出了以下指导原则： 不要将异常处理用于正常的控制流（设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常） 对可以恢复的情况使用受检异常，对编程错误使用运行时异常 避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生） 优先使用标准的异常 每个方法抛出的异常都要有文档 保持异常的原子性 不要在catch中忽略掉捕获到的异常 列出一些你常见的运行时异常？ - ArithmeticException（算术异常） - ClassCastException （类转换异常） - IllegalArgumentException （非法参数异常） - IndexOutOfBoundsException （下标越界异常） - NullPointerException （空指针异常） - SecurityException （安全异常） 阐述final、finally、finalize的区别。 final：修饰符（关键字）有三种用法：如果一个类被声明为final，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。将变量声明为final，可以保证它们在使用中不被改变，被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为final的方法也同样只能使用，不能在子类中被重写。 finally：通常放在try…catch…的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。 finalize：Object类中定义的方法，Java中允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize()方法可以整理系统资源或者执行其他清理工作。 List，Set,Map是否继承自Collection接口？List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。 阐述ArrayList、Vector、LinkedList的存储性能和特性。ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是Java中的遗留容器。LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector属于遗留容器（Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。 Collection和Collections的区别？Collection是一个接口，它是Set、List等容器的父接口；Collections是个一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。 List、Map、Set三个接口存取元素时，各有什么特点？List以特定索引来存取元素，可以有重复元素。Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。 TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。Collections工具类的sort方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java中对函数式编程的支持）。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker安装和使用]]></title>
    <url>%2F2018%2F09%2F18%2Fdocker%2F</url>
    <content type="text"><![CDATA[docker是什么Docker：是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的，可移植的，自给自足的容器。Docker的核心概念：镜像、仓库、容器 Docker镜像：是一个特殊的文件系统，提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。 Docker 容器（Container）：来运行应用。容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。 仓库（Repository）：是集中存放镜像文件的场所 一次完整docker的操作流程一般的流程中,client发pull命令从仓库把image拉到docker host，然后通过run命令指挥image到host上面弄一个container来跑这个image。当然也可以是相反的流程，client 通过build命令在host上面创建一个自己的image，然后通过push命令把image推到仓库。之后这个image可以被别的人或者自己pull。DOCKER在windows上的安装检查电脑环境检查版本，为了运行docker，你的机器必须是windows7或以上的64bit系统。 另外，你的机器必须支持硬件虚拟化技术(Hardware Virtualization Technology)并且已被启用。对于windows10系统来说，你可以在 任务管理器-&gt;性能 中查看到你的电脑是否开启了虚拟化 怎么开启虚拟化，因为电脑型号不一样，所以每台电脑进入BOIS的方式不一样，重启电脑，我的电脑是Lenovo的ThinkPad，所以我按的是F1，进入BOIS页面，找到Security，把Security下面的Virtualization里面的Intel(R) Virtualization Technology的状态改为Enable 然后再重启就好了。 下载dockerToolboxhttps://get.daocloud.io/toolbox/,下载新版本 全部next就可以了 安转成功之后桌面会多三个图标 如果安装完成之后桌面少了一个Oracle VM VirtualBox 的话，找到你的dockertoolbox安装目录下面的installers下面的virtualbox，双击virtualbox.msi进行安装。 双击Docker Quickstart Terminal图标，启动一个终端，第一次运行会比较就，一般会报下载对应的镜像iso到对C：下的docker路径的错误，把dockertoolbox下的boot2docker.iso复制放到你docker运行下载镜像的位置，再重新启动就可以了。 启动成功会出现这样的界面 docker在linux上的安装1.安装dockeryum install docker.x86_64 启动Dockerservice docker startlinux常用命令 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485ls -a(同时列出隐含文件), -l（输出一个比较完整的格式，除每个文件名外，增加显示文件 类型、权限、硬链接数、所有者名、组名、大小（byte）、及时间信息-----简化为 ll） mkdir 新建目录 例：mkdir test 命令会在当前目录下建立一个名为“test”的新目录 touch 创建文件 例：touch test/readme.txt 在 test 目录下创建 readme.txt文件 cd 切换目录 cd /. 到根目录 cd .. 上一级目录 cd /hahaha/hahaha 到指定目录 pwd 显示当前目录 mv 移动/重命名（加上 -i 参数询问是否覆盖） mv hello rock/ 移动到rock目录下 mv hello rock 重命名为rock cp 拷贝 （加上 -i 参数询问是否覆盖，-r 参数递归调用） cp -ir test/ workspace＂（递归复制 test 目录到 workpace 目录下并在覆盖时提示） rm 删除 （加上 -i 参数确认提示，-r 参数递归调用） rm -ir test/ 递归删除test目录及其子目录并询问 wget url 下载文件到当前目录 sudo 暂时获取超级用户权限（有默认时长）加上 -i 参数 没有时间限制,输入 exit或logout 退出 su 账户名 切换到某某用户模式，没有时间限制 ZIP 工具： 压缩文件 zip target.zip filename 压缩文件夹 zip -r target.zip dir -r 参数表示递归压缩子目录 解压 unzip target.zip tar 工具： -c: 建立压缩档案 -x：解压 -t：查看内容 -r：向压缩归档文件末尾追加文件 -u：更新原压缩包中的文件 这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用 其中一个。下面的参数是根据需要在压缩或解压档案时可选的。 -z：有gzip属性的 -j：有bz2属性的 -Z：有compress属性的 -v：显示所有过程 -O：将文件解开到标准输出 下面的参数-f是必须的 -f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名 例：tar -xvf file.tar //解压 tar包 tar -xzvf jdk-8u131-linux-x64.tar.gz -C /usr/local/java //解压jdk到指定文件夹 tar -cZf jpg.tar.Z *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用 compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z vim 编辑器： vim test.cpp vim 有两种模式，一种是普通模式，另一种是插入模式。执行上述命令以后进入普通模式。 按下字母键“i”进入插入模式，使用方向键移动光标到需要插入的位置，然后输入想要插入 的内容。编辑完成后按键“Esc”退出回到普通模式,在普通模式下输入冒号“:”，然后输入 w 回车，保存更改。接着输入“:q”退出。也可以直接输入“:wq”保存并退出（注意 w 一定要 在 q之前，先保存再退出）。 查找：在普通模式下输入“/查找内容”，回车，即可定位到第一个匹配项。接着按下字母 键“n”可以查找下一个。 撤销：普通模式下输入“:u”并回车，实现撤销 docker常用命令12345678docker search(-s) nginx 搜索相关镜像 加上-s 参数 选出至少start数范围的镜像docker push 192.168.0.100:5000/ubuntu 推送镜像库到私有源docker rmi（-f） 镜像名：版本号/镜像ID 删除镜像 （加上 -f 参数 强制删除）docker rmi $(docker images -q) 删除所有镜像docker save docker.io/tomcat:7.0.77-jre7 &gt;/root/mytomcat7.tar.gz 导出镜像docker load &lt; /root/mytomcat7.tar.gz 导入镜像如果你想要去查看一个镜像的运行效果，你需要先下载一个镜像，直接运行命令docker pull 镜像名 123456789101112131415161718192021docker ps 查看当前正在运行的容器 docker inspect name/image[name/image...] 查看详细 docker ps -a 查看所有容器的状态 docker start/stop(-t) id/name[name...] 启动/停止某个（多个）容器 -t 指定时间 docker kill (-s) name[name...] 强制中断 -s指定SIGINT信号类型，默认“kill” docker restart (-t) name[name...] 重启 -t 指定时间 docker pause name 暂停 docker unpause name 继续 docker rm(-$) name[name...] 移除 -f --force=false 强制移除运行中容器 -l --link=false 移除指定链接，保留底层容器 -v --volumes=false 移除容器关联卷 指令指南12345容器生命周期管理 — docker [run|start|stop|restart|kill|rm|pause|unpause]容器操作运维 — docker [ps|inspect|top|attach|events|logs|wait|export|port]镜像仓库 — docker [login|pull|push|search]本地镜像管理 — docker [images|rmi|tag|build|history|save|import]其他命令 — docker [info|version] 使用dockerfile制作镜像Docker与微服务-使用Maven插件构建Docker镜像（可以参照http://blog.csdn.net/qq_22841811/article/details/67369530） 打开我们的项目，在我们项目的src/main下面新建一个docker文件，在docker文件里面新建Dockerfile文本 FROM java:8 #From是from那个镜像，最好现在docker里面pull下来，不然构建的时候会在再下一遍 VOLUME /tmp #指定挂载点，该指令使容器中的一个目录具有持久化存储的功能，该目录可被容器本身使用，也可以共享给其他容器 1234567ADD microservice-discovery-eureka-0.0.1-SNAPSHOT.jar app.jar #复制文件RUN bash -c 'touch /app.jar' #run是启动容器后执行的命令EXPOSE 9000 #声明暴露的端口ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/app.jar"] Dockerfile文件修改pom.xml 1234567FROM Jjava:8 //来自那个基础镜像VOLUME /tmp //指定临时挂载点ADD microservice-discovery-eur.jar app.jar //把项目jar添加到app.jar里RUN bash -c 'touch/app.jar' //镜像运行后执行该命令EXPOSE:9000 //暴露出来访问的端口ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/app.jar"] //运行后执行的命令在maven的配置文件里面增加配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;build&gt; &lt;plugins&gt; &lt;!-- docker的maven插件，官网：https://github.com/spotify/docker-maven-plugin --&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.4.12&lt;/version&gt; &lt;configuration&gt; &lt;!-- 注意imageName一定要是符合正则[a-z0-9-_.]的，否则构建不会成功 --&gt; &lt;!-- 详见：https://github.com/spotify/docker-maven-plugin Invalid repository name ... only [a-z0-9-_.] are allowed --&gt; &lt;!-- 如果要将docker镜像push到DockerHub上去的话，这边的路径要和repo路径一致 --&gt; &lt;imageName&gt;eacdy/test&lt;/imageName&gt; &lt;!-- 指定Dockerfile所在的路径 --&gt; &lt;dockerDirectory&gt;$&#123;project.basedir&#125;/src/main/docker&lt;/dockerDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;/&lt;/targetPath&gt; &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt; &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;!-- 以下两行是为了docker push到DockerHub使用的。 --&gt; &lt;serverId&gt;docker-hub&lt;/serverId&gt; &lt;registryUrl&gt;https://index.docker.io/v1/&lt;/registryUrl&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 照上面修改后build之后的项目会报找不到2375端口的错误 需要我们去修改dockerhost的端口 1234567在控制台中输入 docker-machine env $Env:DOCKER_TLS_VERIFY = "1"$Env:DOCKER_HOST = "tcp://192.168.99.100:2376"$Env:DOCKER_CERT_PATH="C:\Users\Administrator\.docker\machine\machines\default（每个人的路径都不一样） 再去修改pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.4.12&lt;/version&gt; &lt;configuration&gt; &lt;imageName&gt;eacdy/test&lt;/imageName&gt; &lt;dockerDirectory&gt;$&#123;project.basedir&#125;/src/main/docker&lt;/dockerDirectory&gt; &lt;!-- 解决Connect to localhost:2375的问题的其中一种方式，注意要跟docker-machine env相一致 --&gt; &lt;dockerHost&gt;https://192.168.99.100:2376&lt;/dockerHost&gt; &lt;dockerCertPath&gt;C:\Users\Administrator\.docker\machine\machines\default&lt;/dockerCertPath&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;/&lt;/targetPath&gt; &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt; &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;!-- 以下两行是为了docker push到DockerHub使用的。 --&gt; &lt;serverId&gt;docker-hub&lt;/serverId&gt; &lt;registryUrl&gt;https://index.docker.io/v1/&lt;/registryUrl&gt; &lt;/configuration&gt;&lt;/plugin&gt; 这样build的项目就不会报错了 完美打包构建build项目。]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建docker私库]]></title>
    <url>%2F2018%2F09%2F12%2F%E6%90%AD%E5%BB%BAdocker%E7%A7%81%E5%BA%93%2F</url>
    <content type="text"><![CDATA[前面关于nexus的操作参考前面nexus的文章 1.新建私有私库 2.新建角色和用户 3.docker上传与下载 使用docker登录私库：密码** docker login youstudio.cn:7182给镜像打标记，设置为私库将要提交的路径： docker tag nginx:1.13.5 youstudio.cn:7182/xcfr/test/nginx:1.0.0 往私库上放置一个镜像： docker push youstudio.cn:7182/xcfr/test/nginx:1.0.0 从私库上拉取刚刚上传的镜像一个镜像： docker pull youstudio.cn:7182/xcfr/test/nginx:1.0.0 通过浏览器查看结果： 点击打开链接]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>docker私库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于highcharts+easui+java生成饼图]]></title>
    <url>%2F2018%2F09%2F12%2F%E5%9F%BA%E4%BA%8Ehighcharts-easui-java%E7%94%9F%E6%88%90%E9%A5%BC%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[前言：第一次接触饼图，刚开始没有思路，后面在网上找了一下对比了一下，发现用highcharts插件去生成图表特别简单，用起来还是非常简单的，只需要后台返回相应的数据前台用json接收一下，就可以完美的实现了。 一、先来个实体展示，让大家看看效果 （效果还是美美的） 二、要实现这个效果首先要去highcharts官网去下载你自己需要的图表简单的介绍下Highcharts，Highcharts是一个非常流行，界面美观的纯Javascript图表库。它主要包括两个部分：Highcharts和Highstock。Highcharts可以为您的网站或Web应用程序提供直观，互动式的图表。目前支持线，样条，面积，areaspline，柱形图，条形图，饼图和散点图类型。Highstock可以为您方便地建立股票或一般的时间轴图表。它包括先进的导航选项，预设的日期范围，日期选择器，滚动和平移等等。（下面是highcharts官网地址和demo） HIghChartS官网：http://www.highcharts.com/ HighCharts Demo:http://www.highcharts.com/demo/ 2.1引入相应的js文件才能实现页面效果由于我在Web开发框架中，主要采用了MVC+EasyUI的方式，因包含的文件如下所示。(每个图表需要引得文件官网的demo里面都有） 123456789101112131415161718&lt;script type="text/javascript" src="&lt;%=basePath%&gt;/view/report/highcharts.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="&lt;%=basePath%&gt;/js/grid.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="&lt;%=basePath%&gt;/view/report/exporting.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/view/report/jquery.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="&lt;%=basePath%&gt;/view/report/jquery.min.js"&gt;&lt;/script&gt;@*图表JS文件应用*@&lt;script type="text/javascript" src="&lt;%=basePath%&gt;/view/report/highcharts.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="&lt;%=basePath%&gt;/js/grid.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="&lt;%=basePath%&gt;/view/report/exporting.js"&gt;&lt;/script&gt; 三、图表的js代码首先是官网下载下来的图表代码 12345678910111213141516171819202122232425262728293031323334353637383940414243$(function () &#123; $('#container').highcharts(&#123; chart: &#123; plotBackgroundColor: null, plotBorderWidth: null, plotShadow: false &#125;, title: &#123; text: '2014 某网站上各个浏览器的访问量占比' &#125;, tooltip: &#123; headerFormat: '&#123;series.name&#125;&lt;br&gt;', pointFormat: '&#123;point.name&#125;: &lt;b&gt;&#123;point.percentage:.1f&#125;%&lt;/b&gt;' &#125;, plotOptions: &#123; pie: &#123; allowPointSelect: true, cursor: 'pointer', dataLabels: &#123; enabled: false &#125;, showInLegend: true &#125; &#125;, series: [&#123; type: 'pie', name: '浏览器访问量占比', data: [ ['Firefox', 45.0], ['IE', 26.8], &#123; name: 'Chrome', y: 12.8, sliced: true, selected: true &#125;, ['Safari', 8.5], ['Opera', 6.2], ['其他', 0.7] ] &#125;] &#125;);&#125;); 改动后的样式，只需要把data换成动态的数组用json来接收 1234567891011121314151617181920212223242526272829303132333435var chart2= Highcharts.chart('container1', &#123; chart: &#123; margin: [0, 0, 0, 0], width:300, padding:[0, 0, 0, 0], plotBackgroundColor: null, plotBorderWidth: null, plotShadow: false &#125;, title: &#123; text: '各航站异常行李数量' &#125;, /* tooltip: &#123; headerFormat: '&#123;series.name&#125;&lt;br&gt;', pointFormat: '&#123;point.name&#125;: &lt;b&gt;&#123;point.percentage:.1f&#125;%&lt;/b&gt;' &#125;,*/ plotOptions: &#123; pie: &#123; allowPointSelect: true, cursor: 'pointer', dataLabels: &#123; enabled: true, format: '&lt;b&gt;&#123;point.name&#125;&lt;/b&gt;', style: &#123; color: (Highcharts.theme &amp;&amp; Highcharts.theme.contrastTextColor) || 'black' &#125; &#125; &#125; &#125;, series: [&#123; type: 'pie', name: '异常行李量', data: [ ] &#125;] &#125;); 我的ajax请求 function getPieJson(){ var data1 = []; $.ajax({ type : “POST”, // 提交方式 url :servicefulPath + ‘/irregularBagReportTotal/pieChart’, success : function(result){ var json = result.data; for ( var key in json) { //通过遍历对象属性的方法，遍历键值对，获得key，然后通过 对象[key]获得对应的值 if (json.hasOwnProperty(key)) { data1.push([key, json[key]]); } } chart2.series[0].setData(data1); } }); } 四，后台代码格式（注明：每个的后台框架和条件都不一样，最重要的是返回一个map数据到前台就可以了） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//饼图 public Map&lt;String, Object&gt; pieChart()&#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); StringBuffer sql = new StringBuffer("SELECT SUM (E .LOSE) AS lose,SUM (E .MISSHIPMENT) AS miss,"); sql.append(" SUM (E .LEAKAGE_LUCK) AS leak,SUM (E . LESS) AS LESS,SUM (E .DAMAGED) AS damaged"); sql.append(" FROM E_ABNOM_BAGGA_TRAN E"); Query query = entityManager.createNativeQuery(sql.toString());//执行sql语句 Object[] o = (Object[])query.getResultList().get(0); IrregularBagReport count = new IrregularBagReport(); //丢失 if (o[0] == null) &#123; count.setLost(BigDecimal.ZERO); &#125; else &#123; count.setLost((BigDecimal) o[0]); &#125; //错运 if (o[1] == null) &#123; count.setMisshipMent(BigDecimal.ZERO); &#125; else &#123; count.setMisshipMent((BigDecimal) o[1]); &#125; //漏运 if (o[2] == null) &#123; count.setLeakageLuck(BigDecimal.ZERO); &#125; else &#123; count.setLeakageLuck((BigDecimal) o[2]); &#125; //少收 if (o[3] == null) &#123; count.setLess(BigDecimal.ZERO); &#125; else&#123; count.setLess( (BigDecimal) o[3]); &#125; //破损 if (o[4] == null) &#123; count.setDamaged(BigDecimal.ZERO); &#125; else &#123; count.setDamaged((BigDecimal) o[4]); &#125; map.put("丢失", count.getLost()); map.put("错运", count.getMisshipMent()); map.put("漏运",count.getLeakageLuck()); map.put("少收", count.getLess()); map.put("破损", count.getDamaged()); return map; &#125; 综上所述，按照上面的步骤就能生成饼图了，欢迎大佬们评论留言。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>easui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react+dva+antd的骚操作]]></title>
    <url>%2F2018%2F09%2F12%2Freact%2Bdva%2Bantd%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[前言：原谅我直接跳过react的基础，直接就讲react+dva的实际应用，因为直接从项目结构来讲，我觉得学习的成本更低，开发的速度更快，当然有时间的话还是建议冲react的基础学起。react的参考资料：建议先从React 入门实例教程开始学react的全家桶系列也不错 dva的参考资料：dva的官方指南有很多不错的脚手架ant design组合ant design UI可以说非常方便 例子实现效果 前提条件 确保 node 版本是 6.5 + 用 cnpm 或 yarn 能节约你安装依赖的时间 第一步：打开cmd，切换到你要安装的目录，使用npm安装dva-cli123$ npm i dva-cli@0.7 -g$ dva -v0.7.0 然后可以在命令行输入命令创建应用 12$ dva new user-dashboard$ cd user-dashboard 第二步，配置 antd 和 babel-plugin-importbabel-plugin-import 主要是用于按需引入 antd 的 JavaScript 和 CSS，这样打包出来的文件不至于太大。详情请看dva 12$ npm i antd --save$ npm i babel-plugin-import --save-dev 如果dva的版本是在0.7一下的话是没有.roadhogrc文件，修改 .roadhogrc，在 “extraBabelPlugins” 里加上，0.7一下的话是修改.webpackrc文件： 1["import", &#123; "libraryName": "antd", "style": "css" &#125;] 第三步，配置代理，能通过 RESTFul 的方式访问修改 .roadhogrc，加上 “proxy” 配置，或者修改.webpackrc文件也可：可以通过http://localhost:8000/api/users来查看json数据1234567"proxy": &#123; "/api": &#123; "target": "http://jsonplaceholder.typicode.com/", "changeOrigin": true, "pathRewrite": &#123; "^/api" : "" &#125; &#125;&#125;, 然后启动应用：可以新开一个命令行窗口 1$ npm start 然后系统就会自动在浏览器中打开页面，也可以访问http://localhost:8000/ 第四步，生成 users 路由 1dva g route users 输入这个命令就会在src的routes生成两个文件，一个User.js,一个是User.css，然后访问 http://localhost:8000/#/users 。 第五步，构造 users model 和 service同上，用dva的命令生成文件 1dva g model users 然后修改 src/models/users.js ： 1234567891011121314151617181920212223242526272829import * as usersService from '../services/users';export default &#123; namespace: 'users', state: &#123; list: [], total: null, &#125;, reducers: &#123; save(state, &#123; payload: &#123; data: list, total &#125; &#125;) &#123; return &#123; ...state, list, total &#125;; &#125;, &#125;, effects: &#123; *fetch(&#123; payload: &#123; page &#125; &#125;, &#123; call, put &#125;) &#123; const &#123; data, headers &#125; = yield call(usersService.fetch, &#123; page &#125;); yield put(&#123; type: 'save', payload: &#123; data, total: headers['x-total-count'] &#125; &#125;); &#125;, &#125;, subscriptions: &#123; setup(&#123; dispatch, history &#125;) &#123; return history.listen((&#123; pathname, query &#125;) =&gt; &#123; if (pathname === '/users') &#123; dispatch(&#123; type: 'fetch', payload: query &#125;); &#125; &#125;); &#125;, &#125;,&#125;; 在目标文件夹中新增 src/services/users.js： 12345import request from '../utils/request';export function fetch(&#123; page = 1 &#125;) &#123; return request(`/api/users?_page=$&#123;page&#125;&amp;_limit=5`);&#125; 由于我们需要从 response headers 中获取 total users 数量，所以需要改造下 src/utils/request.js： 12345678910111213141516171819202122232425262728293031323334353637import fetch from 'dva/fetch';function checkStatus(response) &#123; if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) &#123; return response; &#125; const error = new Error(response.statusText); error.response = response; throw error;&#125;/** * Requests a URL, returning a promise. * * @param &#123;string&#125; url The URL we want to request * @param &#123;object&#125; [options] The options we want to pass to "fetch" * @return &#123;object&#125; An object containing either "data" or "err" */export default async function request(url, options) &#123; const response = await fetch(url, options); checkStatus(response); const data = await response.json(); const ret = &#123; data, headers: &#123;&#125;, &#125;; if (response.headers.get('x-total-count')) &#123; ret.headers['x-total-count'] = response.headers.get('x-total-count'); &#125; return ret;&#125; 第六步，添加界面，让用户列表展现出来用 dva-cli 生成 component： 1$ dva g component Users/Users 然后修改生成出来的 src/components/Users/Users.js 和 src/components/Users/Users.css，并在 src/routes/Users.js 中引用他。User.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import React from 'react';import &#123; connect &#125; from 'dva';import &#123; Table, Pagination, Popconfirm, Button &#125; from 'antd';import &#123; routerRedux &#125; from 'dva/router';import styles from './Users.css';import &#123; PAGE_SIZE &#125; from '../../constants';import UserModal from './UserModal';function Users(&#123; dispatch, list: dataSource, loading, total, page: current &#125;) &#123; function deleteHandler(id) &#123; dispatch(&#123; type: 'users/remove', payload: id, &#125;); &#125; function editHandler(id, values) &#123; dispatch(&#123; type: 'users/patch', payload: &#123; id, values &#125;, &#125;); &#125; function pageChangeHandler(page) &#123; dispatch(routerRedux.push(&#123; pathname: '/users', query: &#123; page &#125;, &#125;)); &#125; function createHandler(values) &#123; dispatch(&#123; type: 'users/create', payload: values, &#125;); &#125; const columns = [ &#123; title: '姓名', dataIndex: 'name', key: 'name', render: text =&gt; &lt;a href=""&gt;&#123;text&#125;&lt;/a&gt;, &#125;, &#123; title: '邮箱', dataIndex: 'email', key: 'email', &#125;, &#123; title: '地址', dataIndex: 'website', key: 'website', &#125;, &#123; title: '操作', key: 'operation', render: (text, record) =&gt; ( &lt;span className=&#123;styles.operation&#125;&gt; &lt;UserModal record=&#123;record&#125; onOk=&#123;editHandler.bind(null, record.id)&#125;&gt; &lt;a&gt;修改&lt;/a&gt; &lt;/UserModal&gt; &lt;Popconfirm title="Confirm to delete?" onConfirm=&#123;deleteHandler.bind(null, record.id)&#125;&gt; &lt;a href=""&gt;删除&lt;/a&gt; &lt;/Popconfirm&gt; &lt;/span&gt; ), &#125;, ]; return ( &lt;div className=&#123;styles.normal&#125;&gt; &lt;div&gt; &lt;div className=&#123;styles.create&#125;&gt; &lt;UserModal record=&#123;&#123;&#125;&#125; onOk=&#123;createHandler&#125;&gt; &lt;Button type="primary"&gt;增加用户&lt;/Button&gt; &lt;/UserModal&gt; &lt;/div&gt; &lt;Table columns=&#123;columns&#125; dataSource=&#123;dataSource&#125; loading=&#123;loading&#125; rowKey=&#123;record =&gt; record.id&#125; pagination=&#123;false&#125; /&gt; &lt;Pagination className="ant-table-pagination" total=&#123;total&#125; current=&#123;current&#125; pageSize=&#123;PAGE_SIZE&#125; onChange=&#123;pageChangeHandler&#125; /&gt; &lt;/div&gt; &lt;/div&gt; );&#125;function mapStateToProps(state) &#123; const &#123; list, total, page &#125; = state.users; return &#123; loading: state.loading.models.users, list, total, page, &#125;;&#125;export default connect(mapStateToProps)(Users); User.css 123456789.normal &#123;&#125;.create &#123; margin-bottom: 1.5em;&#125;.operation a &#123; margin: 0 .5em;&#125; 这边主要是对 model 进行了微调，加入了 page 表示当前页由于 components 和 services 中都用到了 pageSize，所以提取到 src/constants.js改完后，切换到浏览器，应该能看到带分页的用户列表 第七步，添加 layout 添加 layout 布局，使得我们可以在首页和用户列表页之间来回切换。2.添加布局，src/components/MainLayout/MainLayout.js 和 CSS 文件在 src/routes 文件夹下的文件中引用这个布局 12345678910111213141516import React from 'react';import &#123; Router, Route &#125; from 'dva/router';import IndexPage from './routes/IndexPage';import Users from "./routes/Users.js";function RouterConfig(&#123; history &#125;) &#123; return ( &lt;Router history=&#123;history&#125;&gt; &lt;Route path="/" component=&#123;IndexPage&#125; /&gt; &lt;Route path="/users" component=&#123;Users&#125; /&gt; &lt;/Router&gt; );&#125;export default RouterConfig; 第八步，通过 dva-loading 处理 loading 状态dva 有一个管理 effects 执行的 hook，并基于此封装了 dva-loading 插件。通过这个插件，我们可以不必一遍遍地写 showLoading 和 hideLoading，当发起请求时，插件会自动设置数据里的 loading 状态为 true 或 false 。然后我们在渲染 components 时绑定并根据这个数据进行渲染。 先安装 dva-loading ： 1npm i dva-loading --save 修改 src/index.js 加载插件，在对应的地方加入下面两句： 12import createLoading from 'dva-loading';app.use(createLoading()); 然后在 src/components/Users/Users.js 里绑定 loading 数据： 1loading: state.loading.models.users, 具体参考这个 例子。 第九步，处理分页只改一个文件 src/components/Users/Users.js 就好。 处理分页有两个思路： 发 action，请求新的分页数据，保存到 model，然后自动更新页面 切换路由 (由于之前监听了路由变化，所以后续的事情会自动处理)我们用的是思路 2 的方式，好处是用户可以直接访问到 page 2 或其他页面。 参考这个 例子。 第10步，用户的修改，删除，增加都是对三个文件的操作 service, 修改 src/services/users.js： 123456789101112131415161718192021222324252627282930import request from '../utils/request';import &#123; PAGE_SIZE &#125; from '../constants';export function fetch(&#123; page &#125;) &#123; return request(`/api/users?_page=$&#123;page&#125;&amp;_limit=$&#123;PAGE_SIZE&#125;`); &#125; //删除export function remove(id) &#123; return request(`/api/users/$&#123;id&#125;`, &#123; method: 'DELETE', &#125;);&#125;//修改export function patch(id, values) &#123; return request(`/api/users/$&#123;id&#125;`, &#123; method: 'PATCH', body: JSON.stringify(values), headers: &#123; 'Content-Type': 'application/json', 'Accept': 'application/json', &#125;, &#125;);&#125;//新增export function create(values) &#123; return request('/api/users', &#123; method: 'POST', body: JSON.stringify(values), &#125;); &#125; model, 修改 src/models/users.js： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import * as usersService from '../services/users';export default &#123; namespace: 'users', state: &#123; list: [], total: null, page: null, &#125;, reducers: &#123; save(state, &#123; payload: &#123; data: list, total, page &#125; &#125;) &#123; return &#123; ...state, list, total, page &#125;; &#125;, &#125;, effects: &#123; //分页 *fetch(&#123; payload: &#123; page = 1 &#125; &#125;, &#123; call, put &#125;) &#123; const &#123; data, headers &#125; = yield call(usersService.fetch, &#123; page &#125;); yield put(&#123; type: 'save', payload: &#123; data, total: parseInt(headers['x-total-count'], 10), page: parseInt(page, 10), &#125;, &#125;); &#125;, //删除 *remove(&#123; payload: id &#125;, &#123; call, put &#125;) &#123; yield call(usersService.remove, id); yield put(&#123; type: 'reload' &#125;); &#125;, //修改*patch(&#123; payload: &#123; id, values &#125; &#125;, &#123; call, put &#125;) &#123; yield call(usersService.patch, id, values); yield put(&#123; type: 'reload' &#125;);&#125;,//新增*create(&#123; payload: values &#125;, &#123; call, put &#125;) &#123; yield call(usersService.create, values); yield put(&#123; type: 'reload' &#125;); &#125;, *reload(action, &#123; put, select &#125;) &#123; const page = yield select(state =&gt; state.users.page); yield put(&#123; type: 'fetch', payload: &#123; page &#125; &#125;); &#125;, &#125;, subscriptions: &#123; setup(&#123; dispatch, history &#125;) &#123; return history.listen((&#123; pathname, query &#125;) =&gt; &#123; if (pathname === '/users') &#123; dispatch(&#123; type: 'fetch', payload: query &#125;); &#125; &#125;); &#125;, &#125;,&#125;; component, 修改 src/components/Users/Users.js，替换 deleteHandler 内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import React from 'react';import &#123; connect &#125; from 'dva';import &#123; Table, Pagination, Popconfirm, Button &#125; from 'antd';import &#123; routerRedux &#125; from 'dva/router';import styles from './Users.css';import &#123; PAGE_SIZE &#125; from '../../constants';import UserModal from './UserModal';function Users(&#123; dispatch, list: dataSource, loading, total, page: current &#125;) &#123;//删除 function deleteHandler(id) &#123; dispatch(&#123; type: 'users/remove', payload: id, &#125;); &#125;//修改 function editHandler(id, values) &#123; dispatch(&#123; type: 'users/patch', payload: &#123; id, values &#125;, &#125;); &#125;//分页 function pageChangeHandler(page) &#123; dispatch(routerRedux.push(&#123; pathname: '/users', query: &#123; page &#125;, &#125;)); &#125;//新增 function createHandler(values) &#123; dispatch(&#123; type: 'users/create', payload: values, &#125;); &#125; const columns = [ &#123; title: '姓名', dataIndex: 'name', key: 'name', render: text =&gt; &lt;a href=""&gt;&#123;text&#125;&lt;/a&gt;, &#125;, &#123; title: '邮箱', dataIndex: 'email', key: 'email', &#125;, &#123; title: '地址', dataIndex: 'website', key: 'website', &#125;, &#123; title: '操作', key: 'operation', render: (text, record) =&gt; ( &lt;span className=&#123;styles.operation&#125;&gt; &lt;UserModal record=&#123;record&#125; onOk=&#123;editHandler.bind(null, record.id)&#125;&gt; &lt;a&gt;修改&lt;/a&gt; &lt;/UserModal&gt; &lt;Popconfirm title="Confirm to delete?" onConfirm=&#123;deleteHandler.bind(null, record.id)&#125;&gt; &lt;a href=""&gt;删除&lt;/a&gt; &lt;/Popconfirm&gt; &lt;/span&gt; ), &#125;, ]; return ( &lt;div className=&#123;styles.normal&#125;&gt; &lt;div&gt; &lt;div className=&#123;styles.create&#125;&gt; &lt;UserModal record=&#123;&#123;&#125;&#125; onOk=&#123;createHandler&#125;&gt; &lt;Button type="primary"&gt;增加用户&lt;/Button&gt; &lt;/UserModal&gt; &lt;/div&gt; &lt;Table columns=&#123;columns&#125; dataSource=&#123;dataSource&#125; loading=&#123;loading&#125; rowKey=&#123;record =&gt; record.id&#125; pagination=&#123;false&#125; /&gt; &lt;Pagination className="ant-table-pagination" total=&#123;total&#125; current=&#123;current&#125; pageSize=&#123;PAGE_SIZE&#125; onChange=&#123;pageChangeHandler&#125; /&gt; &lt;/div&gt; &lt;/div&gt; );&#125;function mapStateToProps(state) &#123; const &#123; list, total, page &#125; = state.users; return &#123; loading: state.loading.models.users, list, total, page, &#125;;&#125;export default connect(mapStateToProps)(Users); 以上就是react+dva+antd实现的一个简单的增删改的操作例子。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>and</tag>
        <tag>dva</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh框架整合之登录以及增删改查]]></title>
    <url>%2F2018%2F09%2F12%2Fssh%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[1.首先阐述一下我用得开发工具，myeclipse2017+oracle,所以我的基本配置步骤可能不一样，下面我用几张图来详解我的开发步骤。 —1先配置structs (Target 选择apache Tomcat (我的版本是8.0))接下来next 依然next,勾选复选框，把Core里面得第一个antlr-2.7.2.jar，因为这个包可能会和hibernate里面得一些包冲突 去掉之后选择下面的spring plus 勾上然后点finsh,然后structs 就配置好了 —2配置spring spring直接finsh —3hibernte配置 第二步，要选4.1，5.1不支持 第三部去掉create 复选框myeclipse会自动安排 然后之前我是已经创建了hibernate到oracle数据库的连接，所以我直接就next 如果hibernate没有连接自己的数据库，要先去配置连接，选择hibernate 然后点击myeclipse derby去新建连接 （最后注意一下在配置安装hibernate之前最好先建一个包用来存放数据库表的pojo类） 二.基本配置好了之后，接下来就是具体的事物了 1.编写Dao接口 2.编写完接口之后，再来写接口的实现类 三.写service接口，和dao 接口是一样的复制过来就行，我就不上图了 四.service接口实现类 接口实现类里面调用方法即可 五.hibernate核心配置文件是applicationContext.xml如果成功配置数据库会直接在src里生成，并映射好数据库表以及连接池，这里面要配置的主要是action，service，dao，spring管理hibernate,定义事务管理器 ，以及事物管理机制，最后aop切面类 这里一定要对应自己的包名，然后是structs配置（structs主要是控制跳转，接受来之action类里面的值然后传输到页面） 六.是我的jsp页面 1.登录页面 首页 最后总结一下吧！ssh学习的新手，开发过程中困难重重，遇到了不少问题，花了不少时间，不过也确实学到了不少东西，页面排版不太好，请多多理解，如果有什么纰漏和错误也希望大家给予指出，有问题可以留言。]]></content>
      <categories>
        <category>框架</category>
        <category>ssh</category>
      </categories>
      <tags>
        <tag>ssh框架整合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Datatables复选框问题]]></title>
    <url>%2F2018%2F09%2F12%2FDatatables%E5%A4%8D%E9%80%89%E6%A1%86%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[关于datatables复选框全选一开始接触到datatables感觉挺坑的，文档少，例子少又不全，遇到了不少问题，希望跟我遇到同样问题的人都可以少走弯路。官方api文档不同的封装方法操作也有点不同页面html12&lt;table class="table table-bordered table-striped" id="productTable"&gt; &lt;/table&gt; js12/*初始化表格*/var catalogTable = loadProduct(); 12345678910$('#productTable').on('click', '.all-select', function (e) &#123; var check = $(catalogTable.rows).find(".csel"); if ($(this).is(":checked")) &#123; $("tr").toggleClass('selected'); check.prop("checked", true); &#125; else &#123; $(this).toggleClass('selected'); check.prop("checked", false); &#125;&#125;); 这段代码主第一行的意思是当单击表格的标题行类名为all-select的复选框时触发事件，操作时换成自己的类名就行了。第二行是获取表格类名为cesl的行,当复选框选中时为ture，没选中为false，就可以实现全选功能。关于这方面的问题都可以问我，欢迎留言]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>dataables</tag>
        <tag>EasyUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsp+servlet实现模糊查询和分页效果]]></title>
    <url>%2F2018%2F09%2F12%2Fjsp%2F</url>
    <content type="text"><![CDATA[1.DAO+MVC包 2.DAO接口方法定义 123456789101112131415161718192021222324252627282930package com.wanczy.dao;import java.math.BigDecimal;import java.util.List;import com.wanczy.pojo.CustomerResourcePOJO;public interface CustomerResourceDAO &#123; /** * * @param sName学校名称 * @param cLevel合作等级 * @param cState合作状态 * @param pageSize一页显示数据的笔数 * @param pageCurrent显示的页数 * @return */ //根据名字水平状态来查询数据，传入页数及当前页数 public List&lt;CustomerResourcePOJO&gt; findByNameLevelState (String sName,int cLevel,int cState,int pageSize,int pageCurrent); //查询数据笔数 public int findCountByNameLevelState(String sName,int cLevel,int cState); //查询单笔数据 public CustomerResourcePOJO findByCId(BigDecimal cID); //修改 public boolean doUpd(CustomerResourcePOJO pojo); //新增 public boolean doIns(CustomerResourcePOJO pojo); //删除 public boolean doDel(BigDecimal cID);&#125; 3.DAO接口方法实现方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236package com.wanczy.dao.impl;import java.math.BigDecimal;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.util.ArrayList;import java.util.List;import com.wanczy.dao.CustomerResourceDAO;import com.wanczy.pojo.CustomerResourcePOJO;public class CustomerResourceDAOImpl implements CustomerResourceDAO &#123; Connection conn ; public CustomerResourceDAOImpl(Connection conn)&#123; this.conn = conn; &#125; public boolean doDel(BigDecimal cID) &#123; boolean flag = false; PreparedStatement pstate = null; try &#123; this.conn.setAutoCommit(false); String sql = "delete from customer_resource where c_id = ?"; pstate = this.conn.prepareStatement(sql); pstate.setBigDecimal(1, cID); pstate.execute();//执行 this.conn.commit(); flag = true; &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; this.conn.rollback(); &#125; catch (Exception e2) &#123; e2.printStackTrace(); // TODO: handle exception &#125; // TODO: handle exception &#125; finally&#123; try &#123; pstate.close(); &#125; catch (Exception e2) &#123; e2.printStackTrace(); // TODO: handle exception &#125; &#125; return flag; &#125; public boolean doIns(CustomerResourcePOJO pojo) &#123; boolean flag = false; PreparedStatement pstate = null; try &#123; this.conn.setAutoCommit(false); String sql = "insert into customer_resource (c_id, s_name, s_add, " + "s_link_man, s_link_tel, c_level, c_state ,s_leader, s_leader_tel)" + "values(scott_squence.nextval,?,?,?,?,?,?,?,?)"; pstate = this.conn.prepareStatement(sql); pstate.setString(1,pojo.getSname()); pstate.setString(2,pojo.getSadd()); pstate.setString(3,pojo.getSlinkMan()); pstate.setString(4,pojo.getSlinkTel()); pstate.setInt(5,pojo.getClevel()); pstate.setInt(6,pojo.getCstate()); pstate.setString(7,pojo.getSleader()); pstate.setString(8,pojo.getSleaderTel()); pstate.execute();//执行 this.conn.commit(); flag = true; &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; this.conn.rollback(); &#125; catch (Exception e2) &#123; e2.printStackTrace(); // TODO: handle exception &#125; // TODO: handle exception &#125; finally&#123; try &#123; pstate.close(); &#125; catch (Exception e2) &#123; e2.printStackTrace(); // TODO: handle exception &#125; &#125; return flag; &#125; public boolean doUpd(CustomerResourcePOJO pojo) &#123; boolean flag = false; PreparedStatement pstate = null; try &#123; this.conn.setAutoCommit(false); String sql = "update customer_resource set s_name=?, s_add=?, " + " s_link_man=?, s_link_tel=?, c_level=?, c_state=? ,s_leader=?, s_leader_tel=? where" + " c_id = ?"; pstate = this.conn.prepareStatement(sql); pstate.setString(1,pojo.getSname()); pstate.setString(2,pojo.getSadd()); pstate.setString(3,pojo.getSlinkMan()); pstate.setString(4,pojo.getSlinkTel()); pstate.setInt(5,pojo.getClevel()); pstate.setInt(6,pojo.getCstate()); pstate.setString(7,pojo.getSleader()); pstate.setString(8,pojo.getSleaderTel()); pstate.setBigDecimal(9, pojo.getCid()); pstate.execute();//执行 this.conn.commit(); flag = true; &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; this.conn.rollback(); &#125; catch (Exception e2) &#123; e2.printStackTrace(); // TODO: handle exception &#125; // TODO: handle exception &#125; finally&#123; try &#123; pstate.close(); &#125; catch (Exception e2) &#123; e2.printStackTrace(); // TODO: handle exception &#125; &#125; return flag; &#125; public CustomerResourcePOJO findByCId(BigDecimal cID) &#123; CustomerResourcePOJO pojo = null; PreparedStatement pstate = null; ResultSet res = null; try &#123; String sql = "select s_name, s_add, " + "s_link_man, s_link_tel, c_level, c_state ,s_leader, s_leader_tel from customer_resource where c_id = ?"; pstate = this.conn.prepareStatement(sql); pstate.setBigDecimal(1, cID); res = pstate.executeQuery(); while(res.next())&#123; pojo = new CustomerResourcePOJO(cID,res.getString(1),res.getString(2), res.getString(3),res.getString(4),res.getInt(5),res.getInt(6), res.getString(7),res.getString(8)); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); // TODO: handle exception &#125; finally&#123; try &#123; res.close(); pstate.close(); &#125; catch (Exception e2) &#123; e2.printStackTrace(); &#125; &#125; return pojo; &#125; public List&lt;CustomerResourcePOJO&gt; findByNameLevelState(String sName, int cLevel, int cState, int pageSize, int pageCurrent) &#123; List&lt;CustomerResourcePOJO&gt; list = new ArrayList&lt;CustomerResourcePOJO&gt;(); PreparedStatement pstate = null; ResultSet res = null; try &#123; StringBuffer sql = new StringBuffer(); sql.append("select c_id,s_name, s_add, s_link_man, "+ " s_link_tel, c_level, c_state ,s_leader, "+ " s_leader_tel from (select c_id,s_name, s_add, s_link_man, "+ " s_link_tel, c_level, c_state ,s_leader, "+ " s_leader_tel ,rownum abc "+ " from customer_resource where s_name like ? "); if(cLevel != 0)&#123; sql.append(" and c_level = "+cLevel); &#125; if(cState != 0)&#123; sql.append(" and c_state = "+cState); &#125; sql.append(" ) where abc&gt;? and abc&lt;=? order by c_level,c_state"); pstate = this.conn.prepareStatement(sql.toString()); pstate.setString(1, "%"+sName+"%"); pstate.setInt(2, (pageCurrent-1)*pageSize); pstate.setInt(3, pageCurrent*pageSize); res = pstate.executeQuery(); while(res.next())&#123; CustomerResourcePOJO pojo = new CustomerResourcePOJO(res.getBigDecimal(1),res.getString(2),res.getString(3), res.getString(4),res.getString(5),res.getInt(6),res.getInt(7), res.getString(8),res.getString(9)); list.add(pojo); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); // TODO: handle exception &#125; finally&#123; try &#123; res.close(); pstate.close(); &#125; catch (Exception e2) &#123; e2.printStackTrace(); &#125; &#125; return list; &#125;//查询单笔数据 public int findCountByNameLevelState(String sName, int cLevel, int cState) &#123; int count = 0; PreparedStatement pstate = null; ResultSet res = null; try &#123; StringBuffer sql = new StringBuffer(); sql.append("select count(c_id) from customer_resource where s_name like ? "); if(cLevel != 0)&#123; sql.append(" and c_level = "+cLevel); &#125; if(cState != 0)&#123; sql.append(" and c_state = "+cState); &#125; pstate = this.conn.prepareStatement(sql.toString()); pstate.setString(1, "%"+sName+"%"); res = pstate.executeQuery(); while(res.next())&#123; count = res.getInt(1); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); // TODO: handle exception &#125; finally&#123; try &#123; res.close(); pstate.close(); &#125; catch (Exception e2) &#123; e2.printStackTrace(); &#125; &#125; return 4.Pojo实体类（数据库里的字段） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package com.wanczy.pojo;import java.io.Serializable;import java.math.BigDecimal;public class CustomerResourcePOJO implements Serializable &#123; private BigDecimal cid; private String sname; private String sadd; private String slinkMan; private String slinkTel; private int clevel; private int cstate; private String sleader; private String sleaderTel; public BigDecimal getCid() &#123; return cid; &#125; public void setCid(BigDecimal cid) &#123; this.cid = cid; &#125; public String getSname() &#123; return sname; &#125; public void setSname(String sname) &#123; this.sname = sname; &#125; public String getSadd() &#123; return sadd; &#125; public void setSadd(String sadd) &#123; this.sadd = sadd; &#125; public String getSlinkMan() &#123; return slinkMan; &#125; public void setSlinkMan(String slinkMan) &#123; this.slinkMan = slinkMan; &#125; public String getSlinkTel() &#123; return slinkTel; &#125; public void setSlinkTel(String slinkTel) &#123; this.slinkTel = slinkTel; &#125; public int getClevel() &#123; return clevel; &#125; public void setClevel(int clevel) &#123; this.clevel = clevel; &#125; public int getCstate() &#123; return cstate; &#125; public void setCstate(int cstate) &#123; this.cstate = cstate; &#125; public String getSleader() &#123; return sleader; &#125; public void setSleader(String sleader) &#123; this.sleader = sleader; &#125; public String getSleaderTel() &#123; return sleaderTel; &#125; public void setSleaderTel(String sleaderTel) &#123; this.sleaderTel = sleaderTel; &#125; //一般构造方法都要写一个带id和一个不带id的，还有一个无参的，方便后面的增删改查以及方法的调用 public CustomerResourcePOJO(BigDecimal cid, String sname, String sadd, String slinkMan, String slinkTel, int clevel, int cstate, String sleader, String sleaderTel) &#123; super(); this.cid = cid; this.sname = sname; this.sadd = sadd; this.slinkMan = slinkMan; this.slinkTel = slinkTel; this.clevel = clevel; this.cstate = cstate; this.sleader = sleader; this.sleaderTel = sleaderTel; &#125; public CustomerResourcePOJO( String sname, String sadd, String slinkMan, String slinkTel, int clevel, int cstate, String sleader, String sleaderTel) &#123; super(); this.sname = sname; this.sadd = sadd; this.slinkMan = slinkMan; this.slinkTel = slinkTel; this.clevel = clevel; this.cstate = cstate; this.sleader = sleader; this.sleaderTel = sleaderTel; &#125; public CustomerResourcePOJO() &#123; super(); &#125; &#125; 5.代理类以及工厂类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.wanczy.dao.proxy;import java.math.BigDecimal;import java.sql.Connection;import java.util.List;import com.wanczy.dao.CustomerResourceDAO;import com.wanczy.dao.impl.CustomerResourceDAOImpl;import com.wanczy.pojo.CustomerResourcePOJO;import com.wanczy.pub.GetConnection;public class CustomerResourceDAOProxy implements CustomerResourceDAO &#123; Connection conn = null; CustomerResourceDAOImpl impl = null; public CustomerResourceDAOProxy()&#123; try &#123; this.conn = GetConnection.getConn(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; this.impl = new CustomerResourceDAOImpl(this.conn); &#125; public boolean doDel(BigDecimal cID) &#123; boolean flag = this.impl.doDel(cID); this.close(); return flag; &#125; public boolean doIns(CustomerResourcePOJO pojo) &#123; boolean flag = this.impl.doIns(pojo); this.close(); return flag; &#125; public boolean doUpd(CustomerResourcePOJO pojo) &#123; boolean flag = this.impl.doUpd(pojo); this.close(); return flag; &#125; public CustomerResourcePOJO findByCId(BigDecimal cID) &#123; CustomerResourcePOJO pojo = this.impl.findByCId(cID); this.close(); return pojo; &#125; public List&lt;CustomerResourcePOJO&gt; findByNameLevelState(String sName, int cLevel, int cState, int pageSize, int pageCurrent) &#123; List&lt;CustomerResourcePOJO&gt; list = this.impl.findByNameLevelState(sName, cLevel, cState, pageSize, pageCurrent); this.close(); return list; &#125; public int findCountByNameLevelState(String sName, int cLevel, int cState) &#123; int count = this.impl.findCountByNameLevelState(sName, cLevel, cState); this.close(); return count; &#125; public void close()&#123; try &#123; this.conn.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 6.servlet 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.wanczy.servlet.customerResource;import java.io.IOException;import java.io.PrintWriter;import java.util.List;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.wanczy.dao.factory.CustomerResourceDAOFactory;import com.wanczy.pojo.CustomerResourcePOJO;public class CustomerResourceQuery extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding("utf-8"); response.setCharacterEncoding("utf-8"); response.setContentType("text/html; charset=utf-8"); String sName = request.getParameter("sName"); int cLevel = Integer.parseInt(request.getParameter("cLevel")); int cState = Integer.parseInt(request.getParameter("cState")); int pageSize = Integer.parseInt(request.getParameter("pageSize")); int pageCurrent = Integer.parseInt(request.getParameter("pageCurrent")); List&lt;CustomerResourcePOJO&gt; list = CustomerResourceDAOFactory.getDAOInstance().findByNameLevelState(sName, cLevel, cState, pageSize, pageCurrent); int count = CustomerResourceDAOFactory.getDAOInstance().findCountByNameLevelState(sName, cLevel, cState); PrintWriter out = response.getWriter(); StringBuffer sb = new StringBuffer(); sb.append("&lt;input type='hidden' id='count' value='"+count+"'/&gt;"); sb.append("&lt;table id='sample_1' class='table table-striped table-bordered table-hover table-checkable order-column'&gt;&lt;tr&gt;&lt;th&gt;学校名称&lt;/th&gt;&lt;th&gt;学校地址&lt;/th&gt;&lt;th&gt;联系人&lt;/th&gt;&lt;th&gt;联系人电话&lt;/th&gt;&lt;th&gt;客户等级&lt;/th&gt;&lt;th&gt;合作状态&lt;/th&gt;&lt;th&gt;院校领导&lt;/th&gt;&lt;th&gt;领导电话&lt;/th&gt;&lt;th&gt;操作&lt;/th&gt;&lt;/tr&gt;"); for(CustomerResourcePOJO pojo : list)&#123; String cLevelCode = ""; if(pojo.getClevel() == 1)&#123; cLevelCode = "高"; &#125;else if(pojo.getClevel() == 2)&#123; cLevelCode = "中"; &#125;else&#123; cLevelCode = "低"; &#125; String cStateCode = ""; if(pojo.getCstate() == 1)&#123; cStateCode = "常年合作"; &#125;else if(pojo.getCstate() == 2)&#123; cStateCode = "合作少"; &#125;else&#123; cStateCode = "近年无合作"; &#125; sb.append("&lt;tr&gt;" + "&lt;td&gt;"+pojo.getSname()+"&lt;/td&gt;" + "&lt;td&gt;"+pojo.getSadd()+"&lt;/td&gt;" + "&lt;td&gt;"+pojo.getSlinkMan()+"&lt;/td&gt;" + "&lt;td&gt;"+pojo.getSlinkTel()+"&lt;/td&gt;" + "&lt;td&gt;"+cLevelCode+"&lt;/td&gt;" + "&lt;td&gt;"+cStateCode+"&lt;/td&gt;" + "&lt;td&gt;"+pojo.getSleader()+"&lt;/td&gt;" + "&lt;td&gt;"+pojo.getSleaderTel()+"&lt;/td&gt;" + "&lt;td&gt;&lt;a href='#' onclick='goUpdate("+pojo.getCid()+")'&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;" + "&lt;a href='#' onclick='goDelete("+pojo.getCid()+")'&gt;删除&lt;/a&gt;&lt;/td&gt;" + "&lt;/tr&gt;"); &#125; sb.append("&lt;/table&gt;"); out.print(sb.toString()); out.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 7.web页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134&lt;%@page contentType="text/html; charset=utf-8" %&gt; &lt;% String path=request.getContextPath(); %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;分页操作&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form name = "f"&gt; &lt;fieldset title="查询"&gt; &lt;legend&gt; &lt;span width="12%" height="25" class="STYLE1" style="color: black;"&gt;查询条件&lt;/span&gt; &lt;/legend&gt; 学校名称：&lt;input type="text" name="sName"/&gt; 合作等级：&lt;select name="cLevel"&gt; &lt;option value="0" selected="selected"&gt;全部&lt;/option&gt; &lt;option value="1"&gt;高&lt;/option&gt; &lt;option value="2"&gt;中&lt;/option&gt; &lt;option value="3"&gt;低&lt;/option&gt; &lt;/select&gt; 合作状态：&lt;select name="cState"&gt; &lt;option value="0" selected="selected"&gt;全部&lt;/option&gt; &lt;option value="1"&gt;常年合作&lt;/option&gt; &lt;option value="2"&gt;合作少&lt;/option&gt; &lt;option value="3"&gt;近年无合作&lt;/option&gt; &lt;/select&gt; &lt;input type="button" value="查询" onclick="query(0)"/&gt; &lt;input type="button" value="新增" onclick="goAdd()"/&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;hr/&gt; &lt;div id="showTable"&gt;&lt;/div&gt; &lt;div align="right"&gt; &lt;input type="button" id="first" value="|&lt;" onclick="query(1)"/&gt; &lt;input type="button" id="up" value="&lt;" onclick="query(2)"/&gt; &lt;input type="button" id="next" value="&gt;" onclick="query(3)"/&gt; &lt;input type="button" id="end" value="&gt;|" onclick="query(4)"/&gt; &lt;select id="selectPageCurrent" onchange="query(5)"&gt; &lt;option value="3" selected="selected"&gt;显示3笔&lt;/option&gt; &lt;option value="5"&gt;显示5笔&lt;/option&gt; &lt;option value="10"&gt;显示10笔&lt;/option&gt; &lt;/select&gt; &lt;span id="showPageMessage"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type="text/javascript"&gt; var pageSize = 3;//一页显示的数据笔数 var pageCurrent = 1;//显示的页数 var allCount = 0;//总共的数据笔数 var allPage = 0;//总共数据页数 query(0); function query(num)&#123; var sName = f.sName.value; var cLevel = f.cLevel.value; var cState = f.cState.value; if(num == 1)&#123; pageCurrent = 1; &#125;else if(num == 2)&#123; pageCurrent = pageCurrent -1; &#125;else if(num == 3)&#123; pageCurrent = pageCurrent + 1; &#125;else if(num == 4)&#123; pageCurrent = allPage; &#125;else if(num == 5)&#123; pageCurrent = 1; pageSize = $("#selectPageCurrent").val();//取得每页显示的数据笔数 &#125; $(document).ready(function()&#123; //设置提交的路径，和参数 $.post("&lt;%=path %&gt;/CustomerResourceQuery",&#123;"sName":sName,"cLevel":cLevel,"cState":cState,"pageSize":pageSize,"pageCurrent":pageCurrent&#125;, function(data)&#123;//Servlet执行完之后执行方法，data表示的servlet返回数据内容 $("#showTable").html(data);//显示Servlet返回的内容 controlButton(); &#125;); &#125;); &#125; function controlButton()&#123; allCount = $("#count").val(); if(allCount%pageSize == 0)&#123; allPage = allCount/pageSize &#125;else&#123; allPage = Math.floor(allCount/pageSize) +1; &#125; document.getElementById("first").disabled = false; document.getElementById("up").disabled = false; document.getElementById("next").disabled = false; document.getElementById("end").disabled = false; if(allPage == 1)&#123; document.getElementById("first").disabled = true; document.getElementById("up").disabled = true; document.getElementById("next").disabled = true; document.getElementById("end").disabled = true; &#125;else if(pageCurrent == 1)&#123; document.getElementById("first").disabled = true; document.getElementById("up").disabled = true; &#125;else if(pageCurrent == allPage)&#123; document.getElementById("next").disabled = true; document.getElementById("end").disabled = true; &#125; $("#showPageMessage").html("总共"+allCount+"笔数据，当前显示"+pageCurrent+"页，共"+ allPage+"页"); &#125; function goAdd()&#123; var width = window.screen.width ; var height = window.screen.height ; window.open("add.jsp","新增客户",'height=400,width=300,top='+(height-450)/2+',left='+(width-300)/2+',toolbar=no,menubar=no,scrollbars=no, resizable=no,location=no, status=no'); &#125; function goUpdate(cID)&#123; var width = window.screen.width ; var height = window.screen.height ; window.open("&lt;%=path%&gt;/CustomerResourceFindByCID?cID="+cID,"修改客户",'height=400,width=300,top='+(height-450)/2+',left='+(width-300)/2+',toolbar=no,menubar=no,scrollbars=no, resizable=no,location=no, status=no'); &#125; function goDelete(cID)&#123; if(confirm("确认删除？"))&#123; $(document).ready(function()&#123; //设置提交的路径，和参数 $.post("&lt;%=path %&gt;/CustomerResourceDel",&#123;"cId":cID&#125;, function(data)&#123;//Servlet执行完之后执行方法，data表示的servlet返回数据内容 if(data == "true")&#123; alert("删除成功"); query(0); &#125;else&#123; alert("删除失败，请联系系统管理员"); &#125; &#125;); &#125;); &#125; &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; (本人亲测可以） 8.页面实现效果展示 总结一下吧，mvc+dao设计模式的好处就是实现了java面向对象的思想，接口和方法的实现分开，便于后期的开发和维护，以及功能的增加，通过接口实现类去实现接口中的方法，通过代理类去取得数据库连接池文件及调用方法，有问题可以留言。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jsp</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在服务器的tomcat上部署多个项目]]></title>
    <url>%2F2018%2F09%2F12%2Ftomcat%2F</url>
    <content type="text"><![CDATA[第一步，找到服务器上tomcat的配置文件conf/server.xml文件。类似于我上面的这个文件，找到server.xml里面的 标签，在 标签后面加入如下配置 1234567891011121314151617181920212223242526272829303132&lt;Service name="Catalina2"&gt; &lt;!-- service的名字要对应 --&gt; &lt;Connector port="8099" protocol="HTTP/1.1" &lt;!--端口号与上面一个Service的端口号不一样--&gt; connectionTimeout="20000" redirectPort="8443" URIEncoding="UTF-8"/&gt; &lt;Engine name="Catalina2" defaultHost="localhost"&gt; &lt;!-- service的名字 --&gt; &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm" resourceName="UserDatabase"/&gt; &lt;Host name="localhost" appBase="webapps2" unpackWARs="true" autoDeploy="true" xmlValidation="false" xmlNamespaceAware="false"&gt; &lt;Context path="" docBase="D:\devsoft\apache-tomcat-8.0.35\webapps2\xiaolumouth" reloadable="true" workDir="D:/temp/Tomcat/test" debug="0"/&gt; &lt;/Host&gt; &lt;!-- docBase 是第二个项目的路径--&gt; &lt;/Engine&gt; &lt;/Service&gt; 第二步，复制webapps目录，复制后改变文件名例如webapps2 把另外一个你要跑的项目放在目录webapps2下，在servicexml里面吧docBase属性引向该目录，是你自己的tomcat里面webapps2里面项目的路径就可以了。]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五分钟搭建个人博客]]></title>
    <url>%2F2018%2F07%2F03%2FFirstBlog%2F</url>
    <content type="text"><![CDATA[三步完成个人博客搭建， 这是一篇小白也能看懂的文章，本文主要针对mac OS ，Windows 除了软件安装方式和命令有些区别（装了git bash也一样），其他基本一样。你可能会经常看到类似于这样的博客： 好了，下面开始我们的装逼之路。 1.创建github域名和空间1.1注册首先你需要注册一个Github账号，已有的可以下翻去1.2 创建仓库，注意username，这会影响到你的域名，你的域名将会是 username.github.io ，所以认真的取个名字吧。 （注册需要邮箱激活） 创建仓库然后需要创建一个仓库(repository) 来存储我们的网站，点击首页任意位置出现的 New repository按钮创建仓库, Respository name 中的username.github.io 的username 一定与前面的Owner 一致，记住你的username下面会用到。 2.安装Hexo 可以说是目前最流行的博客框架了，基于Nodejs，更多信息可以google，下面需要安装的工具包括 Git，Nodejs，Hexo。 2.1安装git $ brew install git //安装git https://sourceforge.net/projects/git-osx-installer/可以通过该网址进行安装 2.2 安装node.js先安装nvm，这是Nodejs版本管理器，可以轻松切换Nodejs版本。 这里有两种方式安装。如果使用curl的方式安装，安装完成之后一定要重启终端。1.Homebrew 安装方式，此安装方式无需重启 $ brew install nvm $ mkdir ~/.nvm $ export NVM_DIR=~/.nvm $ . $(brew --prefix nvm)/nvm.sh 安装完成后，重启终端 并执行下列命令即可安装 Node.js。 2.3安装Hexo以上所有都安装完成之后再安装Hexo$ sudo npm install hexo-cli -g 工具安装完成之后，上传到Github上 3.编写，发布接下来我们需要用Hexo初始化一个博客，然后更改一些自定义的配置，或者加上自己喜欢的主题，写上第一篇文章，然后发布到自己的个人Github网站(username.github.io)。 3.1创建博客将下面的 username 替换成你自己的username，执行成功后，会创建出一个名为 username.github.io 的文件夹。 $ hexo init username.github.io 3.2更改配置主题安装 为了使博客不太难看，我们需要安装一个主题，切换至刚刚生成的Hexo 目录，安装主题 `$ cd username.github.io` `$ git clone https://github.com/iissnan/hexo-theme-next themes/next` 这里选了一个极简的主题，也是Hexo众多主题中最受欢迎的一个。上面出现的喵神的主题 在这里。Hexo也有更多主题供你选择。基础配置：打开文件位置username.github.io/_config.yml修改几个键值对，下面把几个必须设置的列出来按需求修改，记得保存， 还有注意配置的键值之间一定要有空格。更多设置… title: dimsky 的 9 维空间 //你博客的名字 author: dimsky //你的名字 language: zh-Hans //语言 中文 theme: next //刚刚安装的主题名称 deploy:type: git //使用Git 发布 repo: https://github.com/username/username.github.io.git // 刚创建的Github仓库 主题配置： 主题配置文件在username.github.io/themes/next/_config.yml中修改，这里略过。设置详情 3.3写文章所有基础框架都已经创建完成，接下来可以开始写你的第一篇博客了在username.github.io/source/_posts下创建你的第一个博客吧，例如，创建一个名为FirstBlog.md的文件，用Markdown大肆发挥吧，注意保存。 3.4测试$ hexo s测试服务启动，你可以在浏览器中输入https://localhost:4000 访问了。 3.5 安装hexo-deployer-git自动部署发布工具$ npm install hexo-deployer-git –save 3.6 发布测试没问题后，我们就生成静态网页文件发布至我们的Github pages 中。$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 最后直接在浏览器里访问你的github的域名就可以你个人博客了]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
</search>
